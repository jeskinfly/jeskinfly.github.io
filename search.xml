<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[homestead问题]]></title>
    <url>%2F2020%2F01%2F08%2Fhomestead-problem%2F</url>
    <content type="text"><![CDATA[问题描述homestead启动时,卡在”SSH auth method: private key”的问题12345678910E:\Work\Vagrant\Homestead (master)vagrant up...homestead: SSH address: 127.0.0.1:2222homestead: SSH username: vagranthomestead: SSH auth method: private keyTimed out while waiting for the machine to boot. This means thatVagrant was unable to communicate with the guest machine withinthe configured ("config.vm.boot_timeout" value) time period.... 解决办法检查 SSH Key 填写是否正确首先，查看homestead.yaml文件中 authorize 选项：1authorize: ~/.ssh/id_rsa.pub 请确定 客户端~/.ssh/id_rsa.pub 文件是否存在 再次，查看服务器中文件/home/vagrant/.ssh/authorized_keys是否保存了客户端公钥。 重新生成 insecure_private_key在 Homestead 文件夹下执行：1vagrant ssh-config 会输出：1234567891011Host homestead-7 HostName 127.0.0.1 User vagrant Port 2222 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile E:/Work/Vagrant/Homestead/.vagrant/machines/homestead-7/virtualbox/private_key IdentitiesOnly yes LogLevel FATAL ForwardAgent yes 移除 IdentityFile 选项里的文件 E:/Work/Vagrant/Homestead/.vagrant/machines/homestead-7/virtualbox/private_key重新运行 vagrant up（vagrant 会自动生成一个新 insecure_private_key 文件）。 在 BIOS 中开启虚拟化技术支持相关问题问百度 重新生成虚拟机确认是否开启虚拟化 执行命令12vagant destroyvagrant up 重置系统设置（Windows）1234netsh advfirewall resetnetsh int ip resetnetsh int ipv6 resetnetsh winsock reset]]></content>
      <categories>
        <category>PHP</category>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[homestead.yaml配置详解]]></title>
    <url>%2F2020%2F01%2F08%2Fhomestead-yaml%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103# 指定 IP ，允许多台虚拟机并存，除了指定 IP 以外，可用选项还有：autonetwork ip: &quot;192.168.10.10&quot;# Homestead.yaml 中的 networks 属性为 Homestead 环境配置网络接口。你可以根据需要配置多个接口：# https://learnku.com/docs/laravel/5.8/homestead/3882#network-interfacesnetworks: - type: &quot;public_network&quot; ip: &quot;192.168.10.20&quot; bridge: &quot;en1: Wi-Fi (AirPort)&quot;# 设置虚拟机内存大小memory: 2048# 设置虚拟机多少核 CPU，cpus: 1# 虚拟机的「主机名词」，默认是`homestead`，登录虚拟机后# 会显示 vagrant@homesteadhostname: homestead# 虚拟机盒子的名称，这是虚拟机软件创建时为虚拟机设置的名词，为 homestead-7name: homestead # 目前支持四个虚拟机类型：virtualbox, vmware_desktop, parallels, hyperv# 请见 https://app.vagrantup.com/laravel/boxes/homesteadprovider: virtualbox# box 用来作为初始化虚拟机的 vagrant box 名称# version 指定虚拟机盒子版本，与 box 参数挂钩box: laravel/homesteadversion: 7.0.0 # 当你的 Vagrant 盒子销毁时，Homestead 能自动备份你的数据库# 请见文档 https://learnku.com/docs/laravel/5.8/homestead/3882#62d8f8backup: true# 虚拟机认证相关，免密码登录# authorize 填写主机公钥文件路径，虚拟机初始化时，会被复制到虚拟机# 的 /home/vagrant/.ssh/authorized_keys文件中，从而实现 SSH 免密码登录。authorize: ~/.ssh/id_rsa.pub# 填本机的 SSH 私钥文件地址。虚拟机初始化时，私钥文件复制到虚拟机# 的 /home/vagrant/.ssh/ 文件夹中，使虚拟机能共享主机上的 SSH 私钥文件，# 使虚拟机具备等同于主机的身份认证。如你主机已经设置好了 GitHub 认证，# 虚拟机也会同步获取到 GitHub 的认证。keys: - ~/.ssh/id_rsa# 文件夹映射，将主机中的文件夹映射到虚拟机里，方便在虚# 拟机读取和操作主机的文件folders: - map: ~/code # 主机里的目录 # 对应映射到的虚拟机目录，也就是说，在此目录下将映射 # 与 ~/code 一致的目录结构 to: /home/vagrant/code # NFS 模式映射文件夹，可以有效提高效率，可选参数是 rsync,smb type: &quot;nfs&quot; - map: &quot;~Project/myapp&quot; to: &quot;/home/vagrant/myapp&quot; type: &quot;rsync&quot; # Vagrant 提供的文件夹挂载选项，请见 # https://www.vagrantup.com/docs/synced-folders/basic_usage.html options: rsync__args: [&quot;--verbose&quot;, &quot;--archive&quot;, &quot;--delete&quot;, &quot;-zz&quot;] rsync__exclude: [&quot;node_modules&quot;]# 添加站点，默认将会生成 Nginx 站点，详见# https://learnku.com/docs/laravel/5.8/homestead/3882#97ea16sites: - map: learnku.test # 域名地址 to: &quot;/home/vagrant/code/learnku/public&quot; # 网站的根目录 php: &apos;5.6&apos; # 选择 PHP 版本, 每个站点可以选择不同的 PHP 版本, 此站点项目选择 php 5.6 版本 # 计划任务，为一个 Homestead 站点的 schedule:run 命令运行起来 schedule: true # 为 Nginx 添加 fastcgi_param 参数 params: - key: FOO value: BAR # 站点类型，默认是 Laravel # 所有类型请见：https://learnku.com/docs/laravel/5.8/homestead/3882#8681e1 type: &quot;laravel&quot; - map: myapp.test to: &quot;/home/vagrant/myapp/public&quot; php: &apos;7.1&apos; # 此站点项目选择 php 7.1 版本databases: - myapp - myapp# 设置 PHP 全局环境变量，variables: - key: &apos;APP_ENV&apos; value: &apos;local&apos; - key: &apos;APP_DEBUG&apos; value: &apos;true&apos;# 端口转发ports: - send: 50000 # 主机端口 to: 5000 # 虚拟机端口 - send: 7777 to: 777 protocol: udp # 端口转发类型]]></content>
      <categories>
        <category>PHP</category>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH登录原理]]></title>
    <url>%2F2020%2F01%2F08%2Fssh%2F</url>
    <content type="text"><![CDATA[口令登录假定你要以用户名user，登录远程主机host。 1$ ssh user@host SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 1$ ssh -p 2222 user@host 如果你是第一次登录对方主机，系统会出现下面的提示： 1234567$ ssh user@hostThe authenticity of host 'host (12.18.429.21)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)? 这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？ 所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。 很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。 假定经过风险衡量以后，用户决定接受这个远程主机的公钥。 1Are you sure you want to continue connecting (yes/no)? yes 系统会出现一句提示，表示host主机已经得到认可。 1Warning: Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts. 然后，会要求输入密码。 1Password: (enter password) 如果密码正确，就可以登录了。 当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。有的终端工具软件有记住密码功能选项，就会跳过输入密码。 每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 公钥登录使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。 所谓”公钥登录”，原理是客户端将自己的公钥发送到服务端，服务端用客户端的公钥加密一个256位的随机字符串，客户端接收后解密，然后将这个字符串和会话标识符session ID合并在一起，对结果应用MD5散列函数并把散列值返回给服务器，服务器进行相同的MD5散列函数，如果客户端和该值可以匹配，就证明用户是可信的，直接允许登录shell，不再要求密码。 关于会话标识符，客户端与服务器实际上是先有会话加密过程，再进行的客户端验证，所以这个会话标识符就是第一个阶段生成的共享密钥。 这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： 1$ ssh-keygen 运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。 运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。 这时再输入下面的命令，将公钥传送到远程主机host上面： 1$ ssh-copy-id user@host 远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。好了，从此你再登录，就不需要输入密码了。 如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 然后，重启远程主机的ssh服务。 12345// ubuntu系统service ssh restart// debian系统/etc/init.d/ssh restart 摘自 阮一峰 - SSH原理与运用（一）：远程登录]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP获取真实IP]]></title>
    <url>%2F2017%2F12%2F27%2Fphp-get-ip%2F</url>
    <content type="text"><![CDATA[变量 $_SERVER[‘HTTP_CLIENT_IP’] 通过请求头传递，可伪造。 $_SERVER[‘HTTP_X_FORWARDED_FOR’] 格式：clientip,proxy1,proxy2。通过请求头传递，可伪造。 $_SERVER[‘REMOTE_ADDR’] 可信的。它是与服务器握手的最后一个ip，可能是用户的真是ip，也可能是用户的代理服务器或自己的反向代理服务器ip地址。 反向代理服务器传递ip123location /&#123; proxy_set_header client-real-ip $remote_addr&#125; 数据库存储ip 存储时使用ip2long()，把ip转换为数字；取出时，使用long2ip()，格式转换回来。]]></content>
      <categories>
        <category>PHP</category>
        <category>IP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云虚拟主机配置子域名指向子目录]]></title>
    <url>%2F2017%2F12%2F27%2Faly-virtual-host%2F</url>
    <content type="text"><![CDATA[背景 我在阿里云有一个免费赠送的虚拟主机，并有一个域名，想部署多个测试的项目，必要是可以用作项目展示，然后通过独立的子域名去访问。 不考虑增加经济支出，如升级虚拟主机为服务器啥的。 方案 利用web服务器(apache、nginx)的重写功能做重定向。 前提你的空间服务器如果安装的web服务器是apache且rewrite功能，才能继续下一步。默认状态为开启。 nginx默认关闭.htaccess的加载，不作介绍。 步骤确认虚拟主机所使用的服务器 访问虚拟主机的任何可用链接，通过响应头判断所使用的服务器，是用的apache，还是nginx。1234567HTTP/1.1 304 Not ModifiedDate: Wed, 27 Dec 2017 07:12:08 GMTServer: ApacheConnection: Keep-AliveKeep-Alive: timeout=15, max=300ETag: "7a04ae-a3a5-553cae160d402"Vary: Accept-Encoding,User-Agent 当前使用的是apache服务器，apache服务器安装时默认支持.htaccess。如果是nginx,默认是不支持的。 nginx配置文件nginx.conf默认：123location ~ /\.ht &#123; deny all;&#125; 根据服务器类型编写.htaccess文件，放在主机根目录12345678910111213141516&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteBase /# 绑定example.mealive.cn 到 example 子目录RewriteCond %&#123;HTTP_HOST&#125; ^example\.mealive\.cn$ [NC]RewriteCond %&#123;REQUEST_URI&#125; !^/example/RewriteRule ^(.*)$ example/$1?Rewrite [L,QSA]#可以绑定多个 只需重复上三行代码并更改一下域名、目录名 就好了#绑定 example2.mealive.cn 到 example2 子目录RewriteCond %&#123;HTTP_HOST&#125; ^example2\.mealive\.cn$ [NC]RewriteCond %&#123;REQUEST_URI&#125; !^/example2/RewriteRule ^(.*)$ example2/$1?Rewrite [L,QSA]&lt;/IfModule&gt; 登录阿里云，在控制台添加域名解析 完成。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>阿里云-虚拟主机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过web实现IM功能]]></title>
    <url>%2F2017%2F12%2F19%2Fweb-im%2F</url>
    <content type="text"><![CDATA[web 的通信方式 浏览器和我们桌面应用的工作方式是不同的，桌面应用通过socket和远程主机上另外一端的一个进程建立TCP连接，从而达到全双工的即时通信。浏览器是客户端请求服务器，服务器返回结果的模式。浏览器要想实现两个客户端的通信，必然要通过服务器进行信息的转发。例如A要和B通信，则应该是A先把信息发送给IM应用服务器，服务器根据A信息中携带的接收者将它再转发给B，同样B到A也是这种模式，如下所示： web 下 IM 特点 双全工通信：浏览器拉取（pull）服务器数据，服务器推送（push）数据到浏览器； 低延迟：浏览器A发送给B的信息经过服务器要快速转发给B，同理B的信息也要快速交给A； 支持跨域：通常客户端浏览器和服务器都是处于网络的不同位置，浏览器本身不允许通过脚本直接访问不同域名下的服务器。 解决方案Ajax 短轮询服务器(polling) 这是最简单的一种解决方案。 原理：在客户端通过Ajax的方式的方式每隔一小段时间就发送一个请求到服务器，服务器返回最新数据，然后客户端根据获得的数据来更新界面。 优点是简单，缺点是对服务器压力较大，浪费带宽流量（通常情况下数据都是没有发生改变的）。 创建一个XHR对象，每2秒就请求服务器一次获取服务器时间并打印出来,客户端Javascript代码：12345678910111213141516171819202122232425262728293031323334353637383940function createXHR()&#123; if(typeof XMLHttpRequest !='undefined')&#123; return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject !='undefined' )&#123; if(typeof arguments.callee.activeXString!="string")&#123; var versions=["MSXML2.XMLHttp.6.0","MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"],i,len; for(i=0,len=versions.length;i&lt;len;i++)&#123; try&#123; new ActiveXObject(versions[i]); arguments.callee.activeXString=versions[i]; break; &#125;catch(ex) &#123; &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125;else&#123; throw new Error("no xhr object available"); &#125; &#125; function polling(url,method,data)&#123; method=method ||'get'; data=data || null; var xhr=createXHR(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300||xhr.status==304)&#123; console.log(xhr.responseText); &#125;else&#123; console.log("fail"); &#125; &#125; &#125;; xhr.open(method,url,true); xhr.send(data); &#125; setInterval(function()&#123; polling('http://localhost:8088/time','get'); &#125;,2000); 服务器NodeJS代码：12345678910111213var http=require('http');var server=http.createServer(function(req,res)&#123;if(req.url=='/time')&#123; //res.writeHead(200, &#123;'Content-Type': 'text/plain','Access-Control-Allow-Origin':'http://localhost'&#125;); res.end(new Date().toLocaleString());&#125;;&#125;).listen(8088,'localhost');server.on('connection',function(socket)&#123; console.log("客户端连接已经建立");&#125;);server.on('close',function()&#123; console.log('服务器被关闭');&#125;); 结果如下： Ajax 长轮询服务器（long-polling） Ajax长轮询服务器（long-polling），解决 Ajax短轮询服务器 浪费带宽流量的问题。 原理：客户端发送一个请求到服务器，服务器查看客户端请求的数据是否发生了变化（是否有最新数据），如果发生变化则立即响应返回，否则保持这个连接并定期检查最新数据，直到发生了数据更新或连接超时。同时客户端连接一旦断开，则再次发出请求，这样在相同时间内大大减少了客户端请求服务器的次数。 优点是节省了带宽流量，缺点是客户端断开服务端还在执行。因为采用的是服务端阻塞方式（死循环，保持响应不返回）。 客户端Javascript代码：1234567891011121314151617181920212223242526272829303132333435363738394041function createXHR()&#123; if(typeof XMLHttpRequest !='undefined')&#123; return new XMLHttpRequest(); &#125;else if(typeof ActiveXObject !='undefined' )&#123; if(typeof arguments.callee.activeXString!="string")&#123; var versions=["MSXML2.XMLHttp.6.0","MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"], i,len; for(i=0,len=versions.length;i&lt;len;i++)&#123; try&#123; new ActiveXObject(versions[i]); arguments.callee.activeXString=versions[i]; break; &#125;catch(ex) &#123; &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125;else&#123; throw new Error("no xhr object available"); &#125; &#125; function longPolling(url,method,data)&#123; method=method ||'get'; data=data || null; var xhr=createXHR(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300||xhr.status==304)&#123; console.log(xhr.responseText); &#125;else&#123; console.log("fail"); &#125; longPolling(url,method,data); &#125; &#125;; xhr.open(method,url,true); xhr.send(data); &#125; longPolling('http://localhost:8088/time','get'); 服务端NodeJS代码：12345678910111213141516var http=require('http');var server=http.createServer(function(req,res)&#123; if(req.url=='/time')&#123; setInterval(function()&#123; sendData(res); &#125;,20000); &#125;;&#125;).listen(8088,'localhost');//用随机数模拟数据是否变化function sendData(res)&#123; var randomNum=Math.floor(10*Math.random()); console.log(randomNum); if(randomNum&gt;=0&amp;&amp;randomNum&lt;=5)&#123; res.end(new Date().toLocaleString()); &#125;&#125; 在服务端通过生成一个在1到9之间的随机数来模拟判断数据是否发生了变化，当随机数在0到5之间表示数据发生了变化，直接返回，否则保持连接，每隔2秒再检测。可以看到返回的时间是没有规律的，并且单位时间内返回的响应数相比polling方式较少。结果如下： Ajax短轮询服务器和Ajax长轮询服务器都是一次性传输数据，在传输数据较小时没有问题，在数据量较大时可采用http-stream方式。 http-stream方式 原理：客户端在一次请求中保持和服务端连接不断开，然后服务端源源不断传送数据给客户端，就好比数据流一样，并不是一次性将数据全部发给客户端。它与polling方式的区别在于整个通信过程客户端只发送一次请求，然后服务端保持与客户端的长连接，并利用这个连接在回送数据给客户端。 基于ajax的http-stream方式 原理：构造一个XHR对象，通过监听它的onreadystatechange事件，当它的readyState为3的时候，获取它的responseText然后进行处理，readyState为3表示数据传送中，整个通信过程还没有结束，所以它还在不断获取服务端发送过来的数据，直到readyState为4的时候才表示数据发送完毕，一次通信过程结束。 缺点是：不兼容IE客户端JavaScript代码：1234567891011121314151617181920212223function createStreamClient(url,progress,done)&#123; //received为接收到数据的计数器 var xhr=new XMLHttpRequest(),received=0; xhr.open("get",url,true); xhr.onreadystatechange=function()&#123; var result; if(xhr.readyState==3)&#123; //console.log(xhr.responseText); result=xhr.responseText.substring(received); received+=result.length; progress(result); &#125;else if(xhr.readyState==4)&#123; done(xhr.responseText); &#125; &#125;; xhr.send(null); return xhr; &#125; var client=createStreamClient("http://localhost:8088/stream",function(data)&#123; console.log("Received:"+data); &#125;,function(data)&#123; console.log("Done,the last data is:"+data); &#125;) 这里由于客户端收到的数据是分段发过来的，所以最好定义一个游标received，来获取最新数据而舍弃之前已经接收到的数据，通过这个游标每次将接收到的最新数据打印出来，并且在通信结束后打印出整个responseText。 服务端NodeJS代码：12345678910111213141516171819var http = require('http');var count = 0;var server = http.createServer(function(req, res)&#123; if(req.url == '/stream')&#123; res.setHeader('content-type', 'multipart/octet-stream'); var timer=setInterval(function()&#123; sendRandomData(timer, res); &#125;, 2000); &#125;;&#125;).listen(8088, 'localhost');function sendRandomData(timer, res)&#123; var randomNum = Math.floor(10000 * Math.random()); console.log(randomNum); if(count++ == 10)&#123; clearInterval(timer); res.end(randomNum.toString()); &#125; res.write(randomNum.toString());&#125; 服务端通过计数器count将数据分十次发送，每次生成一个小于10000的随机数发送给客户端让它进行处理。 基于iframe的http-stream方式 原理：由于低版本的IE不允许在XHR的readyState为3的时候获取其responseText属性，为了达到在IE上使用这个技术，又出现了基于iframe的数据流通信方式。具体来讲，就是在浏览器中动态载入一个iframe,让它的src属性指向请求的服务器的URL，实际上就是向服务器发送了一个http请求，然后在浏览器端创建一个处理数据的函数，在服务端通过iframe与浏览器的长连接定时输出数据给客户端，但是这个返回的数据并不是一般的数据，而是一个类似于parent.process(‘“+randomNum.toString()+”‘)脚本执行的方式，浏览器接收到这个数据就会将它解析成js代码并找到页面上指定的函数去执行，实际上是服务端间接使用自己的数据间接调用了客户端的代码，达到实时更新客户端的目的。 缺点是：使用iframe请求服务端，服务端保持通信连接没有全部返回之前，浏览器title一直处于加载状态，并且底部也显示正在加载，用户体验不好。 客户端Javascript代码：123456789function process(data)&#123; console.log(data); &#125;var dataStream = function (url) &#123; var ifr = document.createElement("iframe"),timer; ifr.src = url; document.body.appendChild(ifr);&#125;; dataStream('http://localhost:8088/htmlfile'); 服务端NodeJS代码：12345678910111213141516171819var http = require('http');var count = 0;var server = http.createServer(function(req, res)&#123; if(req.url == '/htmlfile')&#123; res.setHeader('content-type', 'text/html'); var timer = setInterval(function()&#123; sendRandomData(timer, res); &#125;,2000); &#125;;&#125;).listen(8088, 'localhost');function sendRandomData(timer, res)&#123; var randomNum = Math.floor(10000 * Math.random()); console.log(randomNum.toString()); if(count++ == 10)&#123; clearInterval(timer); res.end("&lt;script type=\"text/javascript\"&gt;parent.process('"+randomNum.toString()+"')&lt;/script&gt;"); &#125; res.write("&lt;script type=\"text/javascript\"&gt;parent.process('"+randomNum.toString()+"')&lt;/script&gt;");&#125; 客户端简单的把数据打印出来，服务端定时发送随机数给客户端，并调用客户端process函数。在IE5中测试结果如下： 基于htmlfile的http-stream方式 iframe的http-stream方式的升级版，解决浏览器title一直处于加载状态，并且底部也显示正在加载的问题。 原理：在IE中，动态生成一个htmlfile对象，这个对象ActiveX形式的com组件，它实际上就是一个在内存中实现的HTML文档，通过将生成的iframe添加到这个内存中的HTMLfile中，并利用iframe的数据流通信方式达到上面的效果。同时由于HTMLfile对象并不是直接添加到页面上的，所以并没有造成浏览器显示正在加载的现象。客户端JavaScript代码： 123456789101112131415161718function connect_htmlfile(url, callback) &#123; var transferDoc = new ActiveXObject("htmlfile"); transferDoc.open(); transferDoc.write( "&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;"+ "document.domain='" + document.domain + "';" + "&lt;\/script&gt;&lt;\/body&gt;&lt;\/html&gt;"); transferDoc.close(); var ifrDiv = transferDoc.createElement("div"); transferDoc.body.appendChild(ifrDiv); ifrDiv.innerHTML = "&lt;iframe src='" + url + "'&gt;&lt;\/iframe&gt;"; transferDoc.callback=callback; setInterval( function () &#123;&#125;, 10000); &#125; function prograss(data) &#123; alert(data); &#125; connect_htmlfile('http://localhost:8088/htmlfile',prograss); 服务端传送给iframe的是这样子1&lt;script type=\&quot;text/javascript\&quot;&gt;callback.process(&apos;&quot;+randomNum.toString()+&quot;&apos;)&lt;/script&gt; 这样就在iframe流的原有方式下避免了浏览器的加载状态。 服务端推送事件 HTML5提供了一种新的技术叫做服务器推送事件SSE，它能够实现客户端请求服务端，然后服务端利用与客户端建立的这条通信连接push数据给客户端，客户端接收数据并处理的目的。从独立的角度看，SSE技术提供的是从服务器单向推送数据给浏览器的功能，但是配合浏览器主动请求，实际上就实现了客户端和服务器的双向通信。它的原理是在客户端构造一个eventSource对象，该对象具有readySate属性，分别表示如下： 0：正在连接到服务器； 1：打开了连接； 2：关闭了连接。 同时eventSource对象会保持与服务器的长连接，断开后会自动重连，如果要强制连接可以调用它的close方法。可以它的监听onmessage事件，服务端遵循SSE数据传输的格式给客户端，客户端在onmessage事件触发时就能够接收到数据，从而进行某种处理。 客户端Javascript代码：12345678910var source=new EventSource('http://localhost:8088/evt'); source.addEventListener('message', function(e) &#123; console.log(e.data); &#125;, false); source.onopen=function()&#123; console.log('connected'); &#125; source.onerror=function(err)&#123; console.log(err); &#125; 服务端：123456789101112131415161718192021var http = require('http');var fs = require("fs");var count = 0;var server = http.createServer(function(req, res)&#123; if(req.url == '/evt')&#123; //res.setHeader('content-type', 'multipart/octet-stream'); res.writeHead(200, &#123; "Content-Type":"tex" + "t/event-stream", "Cache-Control" : "no-cache", 'Access-Control-Allow-Origin' : '*', "Connection" : "keep-alive"&#125;); var timer = setInterval(function()&#123; if(++count == 10)&#123; clearInterval(timer); res.end(); &#125;else&#123; res.write('id: ' + count + '\n'); res.write("data: " + new Date().toLocaleString() + '\n\n'); &#125; &#125;,2000); &#125;;&#125;).listen(8088,'localhost'); 注意这里服务端发送的数据要遵循一定的格式，通常是id:（空格）数据（换行符）data：（空格）数据（两个换行符），如果不遵循这种格式，实际上客户端是会触发error事件的。这里的id是用来标识每次发送的数据的id,是强制要加的。结果如下： 跨域的问题cors实现跨域在服务器请求头添加:1`Access-Control-Allow-Origin&apos;:&apos;*&apos;` 为了安全需要，浏览器的跨域的XHR请求存在限制： 客户端不能使用setRequestHeader设置自定义头部； 不能发送和接收cookie； 调用getAllResponseHeaders()方法总会返回空字符串。 以上这些措施都是为了安全考虑，防止常见的跨站点脚本攻击（XSS）和跨站点请求伪造（CSRF）。 浏览器兼容性：适用于ff,safari,opera,chrome等非IE浏览器 客户端JavaScript代码：123456789101112131415var polling = function()&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; console.log(xhr.responseText); &#125; &#125; &#125; xhr.open('get','http://localhost:8088/cors'); xhr.send(null);&#125;;setInterval(function()&#123; polling();&#125;,1000); 服务器NodeJS代码：1234567891011121314151617var http = require('http');var fs = require("fs");var server = http.createServer(function(req, res)&#123; if(req.url == '/cors')&#123; res.writeHead(200, &#123;'Content-Type': 'text/plain','Access-Control-Allow-Origin':'http://localhost'&#125;); res.end(new Date().toString()); &#125; if(req.url == '/jsonp')&#123; &#125;&#125;).listen(8088, 'localhost');server.on('connection',function(socket)&#123; console.log("客户端连接已经建立");&#125;);server.on('close',function()&#123; console.log('服务器被关闭');&#125;); IE浏览器XDR跨域对于IE8-10，它是不支持使用原生的XHR对象请求跨域服务器的，它自己实现了一个XDomainRequest对象，类似于XHR对象，能够发送跨域请求，它主要有以下限制： cookie不会随请求发送，也不会随响应返回； 只能设置请求头部信息中的Content-Type字段； 不能访问响应头部信息； 只支持Get和Post请求； 只支持IE8-IE10； 客户端JavaScript代码：1234567891011121314var polling = function()&#123; var xdr = new XDomainRequest(); xdr.onload=function()&#123; console.log(xdr.responseText); &#125;; xdr.onerror=function()&#123; console.log('failed'); &#125;; xdr.open('get','http://localhost:8088/cors'); xdr.send(null);&#125;;setInterval(function()&#123; polling();&#125;,1000); 服务器NodeJS代码同上( CORS实现跨域 )。 Jsonp的跨域 原理：利用HTML页面上script标签对跨域没有限制的特点，让它的src属性指向服务端请求的地址，其实是通过script标签发送了一个http请求，服务器接收到这个请求之后，返回的数据是自己的数据加上对客户端JS函数的调用。 客户端JavaScript代码：123456789101112function callback(data)&#123; console.log("获得的跨域数据为:"+data);&#125;function sendJsonp(url)&#123; var oScript=document.createElement("script"); oScript.src=url; oScript.setAttribute('type',"text/javascript"); document.getElementsByTagName('head')[0].appendChild(oScript);&#125;setInterval(function()&#123; sendJsonp('http://localhost:8088/jsonp?cb=callback');&#125;,1000); 服务器NodeJS代码：123456789101112131415161718var http = require('http');var url = require('url');var server = http.createServer(function(req, res)&#123; if(/\/jsonp/.test(req.url))&#123; var urlData = url.parse(req.url, true); var methodName = urlData.query.cb; res.writeHead(200,&#123;'Content-Type':'application/javascript'&#125;); //res.end("&lt;script type=\"text/javascript\"&gt;"+methodName+"("+new Date().getTime()+");&lt;/script&gt;"); res.end(methodName+"("+new Date().getTime()+");"); //res.end(new Date().toString()); &#125;&#125;).listen(8088,'localhost');server.on('connection',function(socket)&#123; console.log("客户端连接已经建立");&#125;);server.on('close',function()&#123; console.log('服务器被关闭');&#125;); websocket实现 以上方案通常称为hack技术。 在HTML5中，浏览器为我们提供了websocket技术，支持H5浏览器的首选方案。websocket整个工作过程： 首先是客户端new 一个websocket对象，该对象会发送一个http请求到服务端，服务端发现这是个webscoket请求，会同意协议转换，发送回客户端一个101状态码的response，以上过程称之为一次握手，经过这次握手之后，客户端就和服务端建立了一条TCP连接，应用层使用wss协议,在该连接上，服务端和客户端就可以进行双向通信了。 wss协议数据格式： FIN字段，它占用1位，表示这是一个数据帧的结束标志，同时也下一个数据帧的开始标志。 opcode字段，它占用4位，当为1时，表示传递的是text帧，2表示二进制数据帧，8表示需要结束此次通信（就是客户端或者服务端哪个发送给对方这个字段，就表示对方要关闭连接了）。9表示发送的是一个ping数据。 mask字段占用1位，为1表示masking-key字段可用， masking-key字段是用来对客户端发送来的数据做unmask操作的。它占用0到4个字节。 Payload字段表示实际发送的数据，可以是字符数据也可以是二进制数据。 客户端JavaScript代码：12345678910111213141516171819202122window.onload = function()&#123; var ws = new WebSocket("ws://127.0.0.1:8088"); var oText = document.getElementById('message'); var oSend = document.getElementById('send'); var oClose = document.getElementById('close'); var oUl = document.getElementsByTagName('ul')[0]; ws.onopen = function()&#123; oSend.onclick = function()&#123; if(!/^\s*$/.test(oText.value))&#123; ws.send(oText.value); &#125; &#125;; &#125;; ws.onmessage = function(msg)&#123; var str = "&lt;li&gt;"+msg.data+"&lt;/li&gt;"; oUl.innerHTML += str; &#125;; ws.onclose=function(e)&#123; console.log("已断开与服务器的连接"); ws.close(); &#125;&#125; 客户端创建一个websocket对象，在onopen时间触发之后（握手成功后），给页面上的button指定一个事件，用来发送页面input当中的信息，服务端接收到信息打印出来，并组装成帧返回给日客户端，客户端再append到页面上。 服务端NodeJS代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//握手成功之后就可以发送数据了var crypto = require('crypto');var WS = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';var server = require('net').createServer(function (socket) &#123; var key; socket.on('data', function (msg) &#123; if (!key) &#123; // 第一次握手，响应头发送101状态码并更新协议 //获取发送过来的Sec-WebSocket-key首部 key = msg.toString().match(/Sec-WebSocket-Key: (.+)/)[1]; key = crypto.createHash('sha1').update(key + WS).digest('base64'); socket.write('HTTP/1.1 101 Switching Protocols\r\n'); socket.write('Upgrade: WebSocket\r\n'); socket.write('Connection: Upgrade\r\n'); //将确认后的key发送回去 socket.write('Sec-WebSocket-Accept: ' + key + '\r\n'); //输出空行，结束Http头 socket.write('\r\n'); &#125; else &#123; // 按wss协议解码数据 var msg = decodeData(msg); console.log(msg); //如果客户端发送的操作码为8,表示断开连接,关闭TCP连接并退出应用程序 if(msg.Opcode == 8)&#123; socket.end(); server.unref(); &#125;else&#123; // 按wss协议编码数据 socket.write(encodeData(&#123;FIN:1, Opcode:1, PayloadData:"接受到的数据为"+msg.PayloadData&#125;)); &#125; &#125; &#125;);&#125;); server.listen(8000,'localhost');//按照websocket数据帧格式提取数据function decodeData(e)&#123; var i = 0,j,s,frame = &#123; //解析前两个字节的基本数据 FIN:e[i] &gt;&gt; 7, Opcode : e[i++] &amp; 15, Mask : e[i] &gt;&gt; 7, PayloadLength : e[i++]&amp;0x7F &#125;; //处理特殊长度126和127 if(frame.PayloadLength == 126) frame.length = (e[i++] &lt;&lt; 8) + e[i++]; if(frame.PayloadLength == 127) i+=4, //长度一般用四字节的整型，前四个字节通常为长整形留空的 frame.length=(e[i++] &lt;&lt; 24) + (e[i++] &lt;&lt; 16) + (e[i++] &lt;&lt; 8) + e[i++]; //判断是否使用掩码 if(frame.Mask)&#123; //获取掩码实体 frame.MaskingKey = [e[i++], e[i++], e[i++], e[i++]]; //对数据和掩码做异或运算 for( j=0, s=[]; j&lt;frame.PayloadLength; j++ ) s.push(e[i+j]^frame.MaskingKey[j%4]); &#125;else s = e.slice(i,frame.PayloadLength); //否则直接使用数据 //数组转换成缓冲区来使用 s = new Buffer(s); //如果有必要则把缓冲区转换成字符串来使用 if(frame.Opcode == 1)s = s.toString(); //设置上数据部分 frame.PayloadData = s; //返回数据帧 return frame;&#125;//对发送数据进行编码function encodeData(e)&#123; var s = [],o = new Buffer(e.PayloadData),l = o.length; //输入第一个字节 s.push((e.FIN &lt;&lt; 7) + e.Opcode); //输入第二个字节，判断它的长度并放入相应的后续长度消息 //永远不使用掩码 if(l &lt; 126) s.push(l); else if(l &lt; 0x10000) s.push(126,(l&amp;0xFF00) &gt;&gt; 2,l &amp; 0xFF); else s.push( 127, 0,0,0,0, //8字节数据，前4字节一般没用留空 (l &amp; 0xFF000000) &gt;&gt; 6,(l &amp; 0xFF0000) &gt;&gt; 4,( l &amp; 0xFF00) &gt;&gt; 2,l &amp; 0xFF ); //返回头部分和数据部分的合并缓冲区 return Buffer.concat([new Buffer(s),o]);&#125; 结果如下：浏览器:服务器: 总结 在实际开发中，推荐选用成熟的实时通讯库（比如socket.io,sockjs,swoole,workerman），他们的原理就是将上面（还有一些其他的如基于Flash的push）的一些技术进行了在客户端和服务端的封装，然后给开发者一个统一调用的接口。在支持websocket的环境下使用websocket，在不支持它的时候启用上面所讲的一些hack技术。]]></content>
      <tags>
        <tag>IM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL查询：获取两个表的差集]]></title>
    <url>%2F2017%2F12%2F19%2Fsql-query-differential%2F</url>
    <content type="text"><![CDATA[场景：假设有A、B两表， id 为关联键 方法一最好理解的方法1select * from A where A.id not in (select B.id from B) 方法二最常用的方法1select * from A left join B on A.id = B.id where B.id is null 方法三最快的方法1select * from B where (select count(1) from A where A.id = B.id ) = 0]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP程序守护进程化]]></title>
    <url>%2F2017%2F10%2F13%2Fphp-daemon%2F</url>
    <content type="text"><![CDATA[一般Server程序都是运行在系统后台，这与普通的交互式命令行程序有很大的区别。glibc里有一个函数daemon。调用此函数，就可使当前进程脱离终端变成一个守护进程，具体内容参见man daemon。PHP中暂时没有此函数，当然如果你有兴趣的话，可以写一个PHP的扩展函数来实现。 PHP命令行程序实现守护进程化有2种方法： 使用nohup1nohup php myprog.php &gt; log.txt &amp; 这里就实现了守护进程化。 单独执行 php myprog.php，当按下ctrl+c时就会中断程序执行，会kill当前进程以及子进程。 php myprog.php &amp;，这样执行程序虽然也是转为后台运行，实际上是依赖终端的，当用户退出终端时进程就会被杀掉。 使用PHP代码来实现代码如下12345678910111213141516171819202122232425262728function daemon()&#123; if(($pid1 = pcntl_fork()) === 0) //First child process &#123; posix_setsid(); //Set first child process as the session leader. if(($pid2 = pcntl_fork()) === 0) //Second child process, which run as daemon. &#123; // todo. here is your code. &#125; else &#123; //First child process exit; exit; &#125; &#125; else &#123; //Wait for first child process exit; pcntl_wait($status); &#125;&#125;daemon();sleep(1000); 用上面代码即可实现守护进程化，当你的PHP程序需要转为后台运行时，只需要调用一次封装好的函数daemonize()即可。注：这里没有实现标准输入输出的重定向。 如何理解?如果不理解这段代码的话，可能需要了解一些Unix系统进程的知识。 系统调用Unix系统由用户空间和内核组成，系统调用允许用户空间的程序通过内核与计算机硬件交互。不同的语言可以通过不同的函数使用系统调用，例如系统调用fork在C中的函数是fork()，在PHP中的函数是pcntl_fork(). PCNTL是Process Control的缩写，PHP中与进程有关的函数都以此开头。 子进程系统中的每个进程都有对应的父进程，进程的ppid标识符即为其父进程的pid。当子进程执行完毕之后，父进程应该通过wait请求这些信息，否则内核会一直保留子进程的状态信息。如果父进程没有调用wait来等待它，子进程就会变成僵尸进程。如果父进程先于子进程结束，子进程通常并不会受影响，而会一直执行下去。父进程结束时系统会扫描其子进程，并将其ppid置为1，成为init进程的子进程。 fork系统调用fork可以使进程衍生一个子进程。两个进程除了pid与ppid之外一模一样。PHP中可以通过pcntl_fork()实现fork，执行完该函数之后，代码会在父子两个进程中继续执行下去，pcntl_fork()在子进程中的返回值为0，在父进程中的返回值为子进程的pid。因此pcntl_fork()经常被放在if条件里，以实现父子进程执行不同的代码，例如： 12345678if(($pid1 = pcntl_fork()) === 0)&#123; //子进程执行此处的代码&#125;else&#123; //父进程执行此处的代码&#125; 进程组每个进程都属于某个组，进程组是一个相关进程的集合，通常是父进程与其子进程。每个进程组都有一个整数id，可以通过posix_getpgrp()函数获得，通常进程组的id和进程组leader的pid相同。当终端收到终止信号(Ctrl-C)时，会转发给进程组中的所有进程。因此，如果你在终端执行一个PHP脚本，并在脚本中fork了子进程。当在终端中按Ctrl-C终止脚本执行时，子进程会同时被中止。 会话组会话组是进程组的集合，当在shell中执行命令：git log | grep shipped | less时，每个命令都有一个进程组，三个进程组属于同一个会话组。当终端收到Ctrl-C时，发送给会话leader的信号会被转发给该会话组的每个进程组，然后再被转发到进程组中的所有进程。 setsidsetsid系统调用会使衍生进程成为一个新会话组leader（同时也是新进程组leader），并返回新建的会话组id。在PHP中对应的函数是posix_setsid(); 为何要fork两次。这个问题就是这段代码中最难解释的部分了，有一些人认为只fork一次就够用了，剩下的观点分为两种，一种是两次fork是为了杜绝守护进程控制终端的可能，另一种认为两次fork是为了避免产生僵尸进程。 防止守护进程控制终端 如果要生成一个守护进程，我们应该确保它不会控制终端，完全在后台运行。而只有会话组leader才能控制终端，因此就要确保守护进程不是会话组leader，这就是第二次fork的作用。 第一次fork并setsid使进程脱离当前终端，第二次fork确保进程永远不会控制终端。 避免守护进程成为僵尸进程 网上另有一种说法是，父进程的存在并非只为生成守护进程。如果只fork一次，且父进程不退出，那么守护进程终止之后就会成为僵尸进程。因此要生成一个子进程来fork出守护进程，fork出守护进程之后子进程就exit，以便将守护进程交由init进程托管。我不是很倾向于这种说法，因为很多fork两次的代码中都不存在「父进程生成守护进程后，还有自己的事要做，它的人生意义并不只是为了生成守护进程」这种事。 关于这个问题，也可以参考stackoverflow上的一个讨论。]]></content>
      <categories>
        <category>PHP</category>
        <category>守护进程</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github如何同步fork？]]></title>
    <url>%2F2017%2F10%2F13%2Fgithub-fork%2F</url>
    <content type="text"><![CDATA[为 fork 配置远程 upstream仓库 列出当前远程仓库配置. 123$ git remote -vorigin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push) 新增要同步的 远程 upstream 仓库. 1$ git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git 验证，为fork添加 upstream仓库是否成功. 12345$ git remote -vorigin https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)origin https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) 同步更新你的fork 从远程upstream 仓库获取所有分支的更新文件和提交历史信息到本地目录 1234567$ git fetch upstreamremote: Counting objects: 75, done.remote: Compressing objects: 100% (53/53), done.remote: Total 62 (delta 27), reused 44 (delta 9)Unpacking objects: 100% (62/62), done.From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY * [new branch] master -&gt; upstream/master 确保你在本地的 master 分支 12$ git checkout masterSwitched to branch 'master' 分支合并 12345678$ git merge upstream/masterUpdating a422352..5fdff0fFast-forward README | 9 ------- README.md | 7 ++++++ 2 files changed, 7 insertions(+), 9 deletions(-) delete mode 100644 README create mode 100644 README.md]]></content>
      <categories>
        <category>Github</category>
        <category>fork</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序如何支持emoji表情？]]></title>
    <url>%2F2017%2F10%2F09%2Fapp-emoji%2F</url>
    <content type="text"><![CDATA[Unicode简述 Unicode（中文：万国码、国际码、统一码、单一码）：把世界上所有语言的文字和所有的符号（如高音谱号、麻将、emoji）用同一套编码表示出来。 Unicode中的平面 Unicode字符分为17组编排，0x0000至0xFFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。 在表示一个Unicode的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。 第０平面也叫做BMP（Basic Multilingual Plane，基本多文种平面），编码从U+0000至U+FFFF，最为重要，存放着世界上各种语言与标记中最常用的字符。 在基本多文种平面（第０平面）里的所有字符，要用4个字（即两个char,16bit,例如U+4AE0，共支持六万多个字符）；在零号平面以外的字符则需要使用5-6个字。 第１平面也叫做SMP（Supplementary Multilingual Plane，多文种补充平面），编码从U+10000到U+1FFFD，放着拼音文字、绘文字（emoji）、字母与数学符号、音符、交通和地图符号、麻将牌、扑克牌、多米诺骨牌、象形文字、楔形文字和其他图形符号。 第２平面也叫做SIP（Supplementary Ideographic Plane，表意文字补充平面），编码从U+20000到U+2FFFD，用于存放汉字中的罕用的汉字或地区的方言用字（如粤语用字及越南语的字喃）。 Unicode中的统一汉字 BMP存放着最常用字与扩展A区的汉字。扩展B区到即将到来的扩展E区都放在SIP中。 在这些区中，除了独立字源的字，还有同一个字源或部首不同的变体或写法。如“ɑ／a”、“強／强”、“戶／户／戸”。这些差异也会在Unicode中用三个不同的编码去表示。所以B区到E区有不少此种字体。 实现方式 Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）。UTF-8、UTF-16、UTF-32都是将数字转换到程序数据的编码方案。 例如UTF-8 如果一个仅包含基本7位ASCII字符的Unicode文件，如果每个字符都使用2字节的原Unicode编码传输，其第一字节的8位始终为0。这就造成了比较大的浪费。对于这种情况，可以使用UTF-8编码，这是一种变长编码，它将基本7位ASCII字符仍用7位编码表示，占用一个字节（首位补0）。而遇到与其他Unicode字符混合的情况，将按一定算法转换，每个字符使用1-3个字节编码，并利用首位为0或1进行识别。这样对以7位ASCII字符为主的西文文档就大幅节省了编码长度（具体方案参见UTF-8）。类似的，对未来会出现的需要4个字节的辅助平面字符和其他UCS-4扩充字符，2字节编码的UTF-16也需要通过一定的算法进行转换。 UTF-8使用一至六个字节为每个字符编码： 128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。 带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。 其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。 其他极少使用的Unicode 辅助平面的字符使用四至六字节编码（Unicode范围由U+10000至U+1FFFFF使用四字节，Unicode范围由U+200000至U+3FFFFFF使用五字节，Unicode范围由U+4000000至U+7FFFFFFF使用六字节）。 解决方式 emoji表情在Unicode中称为绘文字,处于第１平面,编码范围为U+10000~U+1FFFD，使用UTF-8编码需要4个字节。同样的有粤语用词，也是占用4个字节。 utf8_unicode_ci最多支持3个字节的Unicode编码，而utf8mb4_unicode_ci则最多支持4个字节的编码。所以utf8mb4系列覆盖了整个Unicode编码,utf8mb4_unicode_ci是utf8_unicode_ci的超集。但是由于支持的字符集更大，utf8mb4的性能要比utf8系列的字符集低。 MySQL从 5.5 之后开始支持utf8mb4系列的字符集。 浏览器显示表情问题无法显示 在手机、IE11下，该emoji均可正常显示，但是Windows的Chrome下显示为“口”所以”,解决方法是在CSS中font-family中加上”Segoe UI Emoji”，这样根据font-family的回退规则，浏览器会自动以Segoe UI Emoji字体显示表情，Win7开始就支持该字体。 参考UnicodeUnicode字符平面映射UTF-8绘文字]]></content>
      <categories>
        <category>PHP</category>
        <category>emoji</category>
      </categories>
      <tags>
        <tag>emoji</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web网站色彩搭配]]></title>
    <url>%2F2017%2F10%2F06%2Fweb-safecolors%2F</url>
    <content type="text"><![CDATA[什么是Web安全色？ 不同的平台（Mac、PC等）有不同的调色板，不同的浏览器也有自己的调色板。这就意味着对于一幅图，显示在Mac上的Web浏览器中的图像，与它在PC上相同浏览器中显示的效果可能差别很大。 选择特定的颜色时，浏览器会尽量使用本身所用的调色板中最接近的颜色。如果浏览器中没有所选的颜色，就会通过抖动或者混合自身的颜色来尝试重新产生该颜色。 为什么要使用Web安全色？ 为了解决Web调色板的问题，人们一致通过了一组在所有浏览器中都类似的Web安全颜色。 这些颜色使用了一种颜色模型，在该模型中，可以用相应的16制进制值00、33、66、99、CC和FF来表达三原色（RGB）中的每一种。这种基本的Web调色板将作为所有的Web浏览器和平台的标准，它包括了这些16进制值的组合结果。这就意味着，我们潜在的输出结果包括6种红色调、6种绿色调、6种蓝色调。666的结果就给出了216种特定的颜色，这些颜色就可以安全的应用于所有的Web中，而不需要担心颜色在不同应用程序之间的变化。 网站：http://www.bootcss.com/p/websafecolors/ 配色方案 三元色（Tradic），近似色（Analogous）和复合色（Compound） 配色法则 要有「KISS（略: Keep it Simple, stupid）（越简单越好）」这样的思路。首先，尽可能的减少颜色，我们需要考虑下面几点。 背景色： 如白色、灰色等 主色(强调色) ： logo颜色 或 醒目需要引起注意的颜色 次要色(辅助色)： 实例例1：Airbnb（一个旅馆预定网站） 的例子。 地址： https://zh.airbnb.com Airbnb的强调色，是可以显示公司住所地址的红色（英: Rausch）。绿松石色（英: Kazan）是辅助色、背景色则使用了两种灰色（英: Foggy / HOF）。 Airbnb的很多页面，背景色使用的是比较明亮的灰色（英: Foggy）。比如下面的例子、预约房间是非常重要的动作，就使用了作为主色的红色（英: Rausch）。 例2：iphone图标 iphone图标是个标准的应用互补色的例子。 红色和绿色就是一组互补色。iOS 中电话图标和右上角的数量提示标识就很好的构成了色彩对比。 例3：小米官网 (三元色) 小米的强调色是Logo的色彩(#FF6600)。绿色（#83C44E）作为辅助色、背景色则使用了白色和灰色（#F5F5F5）。 １. 从图片提取配色 用ps打开图片后，点击菜单“文件”-》“存储为Web和设备所用格式”，选择gif或png8，颜色选择8，web靠色100%，储存颜色表，最后导进色板里。 2. 最后结果如下: 相关网址1、 https://color.adobe.com/zh/create/color-wheel/2、 https://dribbble.com/]]></content>
      <categories>
        <category>web</category>
        <category>颜色</category>
      </categories>
      <tags>
        <tag>色彩搭配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.tar.xz后缀的文件如何解压]]></title>
    <url>%2F2017%2F09%2F26%2Ftar-xz%2F</url>
    <content type="text"><![CDATA[xz 压缩或解压后缀为.xz格式的文件。默认删除原文件。 -z ：要压缩的文件 -d ：要解压的文件 -k ：保留被解压缩的文件。 tar 常用的归档工具。 -c ：新建归档文件 -x ：还原归档文件 -z ：在过程中使用gzip命令。命名规范：文件后缀为.tar.gz -j ：在过程中使用bzip2命令。命名规范：文件后缀为.tar.bz2 -v : 在过程中显示每个归档文件名称 -f : 必须为最后一个选项,指定档案名称 示例解压test.tar.xz文件1$ xz -d test.tar.xz]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识二维码]]></title>
    <url>%2F2017%2F08%2F29%2Fqrcode%2F</url>
    <content type="text"><![CDATA[什么是二维码 二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理。 常见技术标准有PDF417，QRCode，Code49Code16K，CodeOne等20余种。其中QRCode因为具有识读速度快、信息容量大、占用空间小、保密性强、可靠性高的优势，是目前使用最为广泛的一种二维码。 QRCode 正方形，只有两种颜色，在4个角落的其中3个，印有像“回”字的的小正方图案。QR码是属于开放式的标准，QR码的规格公开，而发明者的专利权益不会被执行。 QR码的“QR”源自“Quick Response”的缩写。 版本信息 QR码一共提供40种不同版本存储密度的结构，对应指示图的“版本信息”，Version 1为21×21模块（模块为QR码中的最小单元），Version 2为25x25像素大小，每增加一个版本，长宽各增加4个模块，最大的版本40为177×177模块。 计算公式是：(V-1)*4 + 21（V是版本号）。 容量 二维码的容量取决于它的版本和错误纠正级别，以及编码的数据类型。 QR码最大数据容量（对于版本40）： 容错率 容错率也叫纠错率，就是指二维码图形如果有破损，仍然可以被机器读取内容，QR码最高可以到7%~30%面积破损仍可被读取。 例如：在二维码中间加上logo，建议选择H级容错率。 基本结构 定位图案 位置探测图形：标记二维码整体的位置。 定位图形：标记二维码的数据内容的位置。 校正图形：大于 Version 2版本的二维码才有，根据版本信息来确定校正图形的数量和位置。主要用于QR码形状的矫正，尤其是当QR码印刷在不平坦的面上，或者拍照时候发生畸变等。 纠错码字 用于修正二维码损坏带来的错误。通过 Reed-Solomon error correction（里德-所罗门纠错算法）来实现的。 版本信息 二维码的规格，QR码符号共有40种规格的矩阵（一般为黑白色），从21×21（版本1），到177×177（版本40），每一版本符号比前一版本 每边增加4个模块。 格式信息 格式信息记录两个方面：纠错级别和用于符号的掩码图案。 纠错级别：包含L、M、Q和H四个级别。L可纠正约7%错误、M级别可纠正约15%错误、Q级别可纠正约25%错误、H级别可纠正约30%错误。RS码原理比较复杂，整体基于“任意k个确定点可表示一个阶数至少为k-1的多项式”，实际上发送超过k个点，就算中间有一些错误，也能通过数学原理反推出最初的多项式，从而获得信息。并不是所有位置都可以缺损，像最明显的那三个角上的方框，直接影响初始定位。中间零散的部分是内容编码，可以容忍缺损。 掩码：用于分解数据区域中可能会混淆扫描仪的模式，例如大的空白区域或看起来像定位符的误导功能。掩模图案被定义在必要时重复以覆盖整个符号的网格上。对应于掩模暗区的模块被反转。使用BCH代码保护格式信息免受错误，每个QR符号中都包含两个完整的副本。 数据编码 Numeric mode，数字编码，标识码为：0001。从 0 到9。如果需要编码的数字的个数不是 3 的倍数，那么，最后剩下的 1 或 2 位数会被转成 4 或 7bits，则其它的每 3 位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸( 表 Table 3 )。 Alphanumeric mode，字符编码，标识码为：0010。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + – . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的 SP 是空格，Char 是字符，Value 是其索引值） 编码的过程是把字符两两分组，然后转成下表的 45 进制，然后转成 11bits 的二进制，如果最后有一个落单的，那就转成 6bits 的二进制。而编码模式和字符的个数需要根据不同的 Version 尺寸编成9, 11 或 13 个二进制( 表 Table 3 )。 Byte mode，字节编码，标识码为：0100。可以是0-255 的 ISO-8859-1 字符。有些二维码的扫描器可以自动检测是否是 UTF-8 的编码。 Kanji mode 这是日文编码，也是双字节编码，标识码为：1000。同样，也可以用于中文编码。日文和汉字的编码会减去一个值。如：在 0X8140 to 0X9FFC 中的字符会减去 8140，在 0XE040 到 0XEBBF 中的字符要减去 0XC140，然后把前两位拿出来乘以 0XC0，然后再加上后两位，最后转成 13bit 的编码。 Extended Channel Interpretation (ECI) mode 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。 Structured Append mode 用于混合编码，也就是说，这个二维码中包含了多种编码格式。 FNC1 mode 这种编码方式主要是给一些特殊的工业或行业用的。比如 GS1 条形码之类的。 示例一：数字编码在 Version 1 的尺寸下，纠错级别为H的情况下，编码： 012345671、 把上述数字分成三组: 012 345 672、把他们转成二进制: 012 转成 0000001100； 345 转成 0101011001； 67 转成 1000011。3、把这三个二进制串起来: 0000001100 0101011001 10000114、把数字的个数转成二进制 (version 1-H 是 10 bits ): 8 个数字的二进制是 00000010005、把数字编码的标志 0001 和第 4 步的编码加到前面: 0001 0000001000 0000001100 0101011001 1000011 示例二：字符编码在 Version 1 的尺寸下，纠错级别为H的情况下，编码: AC-421、从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2)2、两两分组: (10,12) (41,4) (2)3、把每一组转成 11bits 的二进制: (10,12) 1045+12 等于 462 转成 00111001110 (41,4) 4145+4 等于 1849 转成 11100111001 (2) 等于 2 转成 0000104、把这些二进制连接起来：00111001110 11100111001 0000105、把字符的个数转成二进制 (Version 1-H 为 9 bits ): 5 个字符，5 转成 0000001016、在头上加上编码标识 0010 和第 5 步的个数编码: 0010 000000101 00111001110 11100111001 000010 结束符和补齐符假如我们有个“HELLO WORLD”的字符串要编码，根据上面的示例二，我们可以得到下面的编码，12编码 字符数 HELLO WORLD的编码0010 000001010 01100001011 01111000110 10001011100 10110111000 10011010100 001101 结束符 如果编码后的字符长度不足当前版本和纠错级别所存储的容量，则在后续补”0000”,如果容量已满则无需添加终止符。12编码 字符数 HELLO WORLD的编码 结束0010 000001011 01100001011 01111000110 10001011100 10110111000 10011010100 001101 0000 按8bits重排 将编码按8bit一组，形成码字。如果尾部数据不足8bit,则在尾部充0。 上面一共有78个bits，所以，我们还要最后面加上2个0，然后按8个bits分好组：12编码 字符数 HELLO WORLD的编码 结束0010 000001011 01100001011 01111000110 10001011100 10110111000 10011010100 001101 000000 补齐码（Padding Bytes）最后，如果编码后的数据不足版本及纠错级别的最大容量，则在尾部补充 “11101100” 和”00010001”,直到全部填满。（这两个二进制转成十进制是236和17）关于每一个Version的每一种纠错级别的最大Bits限 制，可以参看QR Code Specification的第28页到32页的Table-7一表。 假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码：12编码 字符数 HELLO WORLD的编码 结束符 补齐码00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 11101100 00010001 11101100 编码过程 数据编码：将数据字符转换为位流，每8位一个码字，整体构成一个数据的码字序列。其实知道这个数据码字序列就知道了二维码的数据内容。 对于字母、中文、日文等只是分组的方式、模式等内容有所区别，基本方法是一致的。二维码虽然比起一维条码具有更强大的信息记载能力，但也是有容量限制。 纠错编码：按需要将上面的码字序列分块，并根据纠错等级和分块的码字，产生纠错码字，并把纠错码字加入到数据码字序列后面，成为一个新的序列。 版本信息：生成版本信息放入相应区域内。版本7-40都包含了版本信息，没有版本信息的全为0。二维码上两个位置包含了版本信息，它们是冗余的。版本信息共18位，6X3的矩阵，其中6位时数据为，如版本号8，数据位的信息时 001000，后面的12位是纠错位。 创建二维码基本步骤第一步：数据分析 二维码标准有多种编码模式：数字，字符，字节和日文等模式，每个模式使用不同的方法将文本转换为二进制数字，选择最优化的编码模式，尽可能用最短的一串二进制数字来编码数据。 第二步：数据编码 选择错误校正级别，确定数据的最小版本，增加模式指示符，增加字符计数指示符，使用所选模式进行编码，[分成8位码字和添加补齐码]。 第三步：生成纠错码 将数据码分组，执行多项式长除法，使用逐字节模100011101生成2的幂，生成多项式，生成纠错码，多次运算计算结果 第四步：最终编码 确定块数和纠错码字，数据交替排列，转为二进制，添加剩余位（补齐码） 第五步：矩阵中的模块放置 放置位置探测图形、定位图形、校正图形、数据块。保留版本信息、格式信息区域。 第六步：掩码图案 根据评价条件确定最佳掩码图案 第七步：格式和版本信息 最后放置版本信息、格式信息。 具体编码过程请移步【博客】你今天真好看 常见问题如何导入QR码?QR码系统可以分为两道工序，即QR码的制作和读取。QR码的制作是用“软件和打印机”来实现，读取时使用“扫描仪和应用程序”。用普通手机、智能手机、平板电脑各种移动设备读取QR码。 同样的内容做出来的二维码为什么都不一样？这是由于，这些特定的几何图形按照一定规律，然后随机的分布在平面上。 什么样的情况或造成二维码无法读取？码元变形。 码元是构成QR码的一个方形图块，大小取决于打印机打印头的点数。如下图： 例如，当打印头密度为300dpi时，在5点/码元的情况下码元大小为0.42mm/码元。构成一码元的点数越多，打印质量会越高，运用更稳定，可免受打印粗细、送纸速度不均匀、打印机轴变形、飞白等问题的影响。为了实现稳定的运用，DENSO WAVE INCORPORATED建议每个码元打印4点以上。 在确定QR码版本后，还要确定以码元（构成QR码的一个方形图块）要以多少mm打印，码元大小不同，QR码的实际尺寸也会有所不同。 码元越大，QR码扫描仪就越容易读取。 用图像处理工具等对QR码进行放大或缩小，会导致各个码元的变形。虽然外观上与普通的QR码一样，但实际上却很难读取，甚至有时无法读取。 边缘有文字或图像若在QR码的边缘印上文字或图像，则无法留出足够的边缘空白。这样的二维码很难读取，甚至有时无法读取。 文字和图像等标记摆在二维码上若在和QR码重叠的位置上印上文字或图像等标记，则明暗对比将变得模糊。这样的二维码很难读取，甚至有时无法读取。 可将图像和声音作为数据写入吗？ 一个QR码的容量最多不到3KB（版本40，纠错级别L）。而且，如果是用手机读取，手机所能读取的QR码因厂家和机型而有别，数据量一般为271个字节（版本10，纠错级别L）。可以理解为，通过手机读取QR码时，无法容纳图像和声音。 实际应用微信的扫码登录实现原理 网页版微信刚推出时，无数人被它的登录方式惊艳了一下，不需要输入用户名密码，打开手机微信扫一扫，便自动登录。从原理上讲，二维码只能是一段文本的编码，如何用它实现快捷登录的呢？ 打开网页版微信，可以看到如下的页面： 微信扫码界面 如果你用我查查、支付宝、新浪微博等软件扫码二维码，你会发现此二维码解析出来是如下的网址： 1https://login.weixin.qq.com/l/obsbQ-Dzag== 接下来详细介绍一下扫码登录具体的每个步骤： 扫码登录完整流程 ①：用户 A 访问微信网页版，微信服务器为这个会话生成一个全局唯一的 ID，上面的 URL 中 obsbQ-Dzag== 就是这个 ID，此时系统并不知道访问者是谁。 ②：用户A打开自己的手机微信并扫描这个二维码，并提示用户是否确认登录。 ③：手机上的微信是登录状态，用户点击确认登录后，手机上的微信客户端将微信账号和这个扫描得到的 ID 一起提交到服务器 ④：服务器将这个 ID 和用户 A 的微信号绑定在一起，并通知网页版微信，这个 ID 对应的微信号为用户 A，网页版微信加载用户 A 的微信信息，至此，扫码登录全部流程完成]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zepto.js全局设置headers]]></title>
    <url>%2F2017%2F08%2F10%2Fzepto-ajax%2F</url>
    <content type="text"><![CDATA[最后总结的测试代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpif(!empty($_POST))&#123; echo $_POST['name']; exit;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta name="csrf-token" content="dZhN3E5hVsgrbxr3aZiwUT1WIA0MeZbrJtK62yyK"&gt; &lt;script type="text/javascript" src="http://zeptojs.com/zepto.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; /* // 第一种方式 $(document).on('ajaxBeforeSend', function(e, xhr, options) &#123; var token = $('meta[name="csrf-token"]').attr('content'); if (token) &#123; xhr.setRequestHeader('X-CSRF-TOKEN', token) &#125; &#125;) */ //第二种方式 var token = $('meta[name="csrf-token"]').attr('content'); $.ajaxSettings.headers = &#123; 'X-CSRF-TOKEN': token &#125;; &lt;/script&gt; &lt;title&gt;zeptojs测试&lt;/title&gt; &lt;button onclick="zeptojs()"&gt;ajax&lt;/button&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; function zeptojs() &#123; $.ajax(&#123; url: "zepto.php", type: "post", data: &#123; name: 'Zepto.js' &#125;, success: function(data) &#123; console.log(data); &#125;, &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Zepto简介 Zepto的设计目的是提供Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 如果你会用jquery，那么你也会用zepto。 Zepto的设计目的是提供 jQuery 的类似的API，但并不是100%覆盖jQuery。Zepto设计的目的是有一个5-10k的通用库、下载并快速执行、有一个熟悉通用的API，所以你能把你主要的精力放到应用开发上。 浏览器支持 初级 (100% 支持) Safari 6+ (Mac) Chrome 30+ (Windows, Mac, Android, iOS, Linux, Chrome OS) Firefox 24+ (Windows, Mac, Android, Linux, Firefox OS) iOS 5+ Safari Android 2.3+ Browser Internet Explorer 10+ (Windows, Windows Phone) 次要目标（完全或大部分支持） iOS 3+ Safari Chrome &lt;30 Firefox 4+ Safari &lt;6 Android Browser 2.2 Opera 10+ webOS 1.4.5+ Browser BlackBerry Tablet OS 1.0.7+ Browser Amazon Silk 1.0+ Other WebKit-based browsers/runtimes 需要注意的是Zepto的一些可选功能是专门针对移动端浏览器的；因为它的最初目标在移动端提供一个精简的类似jquery的js库。 在浏览器上(Safari、Chrome和Firefox)上开发页面应用或者构建基于html的web-view本地应用，你如PhoneGap，使用Zepto是一个不错的选择。 总之，Zepto希望在所有的现代浏览器中作为一种基础环境来使用。Zepto不支持旧版本的Internet Explorer浏览器(&lt;10)。 Zepto.js的 Ajax 事件当global: true时。在Ajax请求生命周期内，以下这些事件将被触发。 ajaxStart (global)：如果没有其他Ajax请求当前活跃将会被触发。 ajaxBeforeSend (data: xhr, options)：再发送请求前，可以被取消。 ajaxSend (data: xhr, options)：像 ajaxBeforeSend，但不能取消。 ajaxSuccess (data: xhr, options, data)：当返回成功时。 ajaxError (data: xhr, options, error)：当有错误时。 ajaxComplete (data: xhr, options)：请求已经完成后，无论请求是成功或者失败。 ajaxStop (global)：如果这是最后一个活跃着的Ajax请求，将会被触发。 默认情况下，Ajax事件在document对象上触发。然而，如果请求的 context 是一个DOM节点，该事件会在此节点上触发然后再DOM中冒泡。唯一的例外是 ajaxStart &amp; ajaxStop这两个全局事件。 12345678910111213141516171819202122232425262728293031323334$(document).on('ajaxBeforeSend', function(e, xhr, options)&#123; // This gets fired for every Ajax request performed on the page. // The xhr object and $.ajax() options are available for editing. // Return false to cancel this request.&#125;)$.ajax(&#123; type: 'GET', url: '/projects', // data to be added to query string: data: &#123; name: 'Zepto.js' &#125;, // type of data we are expecting in return: dataType: 'json', timeout: 300, context: $('body'), success: function(data)&#123; // Supposing this JSON payload was received: // &#123;"project": &#123;"id": 42, "html": "&lt;div&gt;..." &#125;&#125; // append the HTML to context object. this.append(data.project.html) &#125;, error: function(xhr, type)&#123; alert('Ajax error!') &#125;&#125;)// post a JSON payload:$.ajax(&#123; type: 'POST', url: '/projects', // post payload: data: JSON.stringify(&#123; name: 'Zepto.js' &#125;), contentType: 'application/json'&#125;) 根据以上可以实现第一种方法。 123$(document).on('ajaxBeforeSend', function(e, xhr, options)&#123; setting.setRequestHeader('name','value')&#125;) 变种： 123$(document).on('ajaxSend', function(e, xhr, options)&#123; setting.setRequestHeader('name','value')&#125;) $.ajaxSettings一个包含Ajax请求的默认设置的对象。大部分的设置在 $.ajax中已经描述。以下设置为全局非常有用： timeout (默认： 0)：对Ajax请求设置一个非零的值指定一个默认的超时时间，以毫秒为单位。 global (默认： true)：设置为false。以防止触发Ajax事件。 xhr (默认：XMLHttpRequest factory)：设置为一个函数，它返回XMLHttpRequest实例(或一个兼容的对象) accepts : 从服务器请求的MIME类型，指定 dataType 值： script: “text/javascript, application/javascript” json: “application/json” xml: “application/xml, text/xml” html: “text/html” text: “text/plain” 以上只列出了部分参数。查看源码：1234567891011121314151617181920212223242526272829303132333435363738394041$.ajaxSettings = &#123; // Default type of request type: 'GET', // Callback that is executed before request beforeSend: empty, // Callback that is executed if the request succeeds success: empty, // Callback that is executed the the server drops error error: empty, // Callback that is executed on request complete (both: error and success) complete: empty, // The context for the callbacks context: null, // Whether to trigger "global" Ajax events global: true, // Transport xhr: function () &#123; return new window.XMLHttpRequest() &#125;, // MIME types mapping // IIS returns Javascript as "application/x-javascript" accepts: &#123; script: 'text/javascript, application/javascript, application/x-javascript', json: jsonType, xml: 'application/xml, text/xml', html: htmlType, text: 'text/plain' &#125;, // Whether the request is to another domain crossDomain: false, // Default timeout timeout: 0, // Whether data should be serialized to string processData: true, // Whether the browser should be allowed to cache GET responses cache: true, //Used to handle the raw response data of XMLHttpRequest. //This is a pre-filtering function to sanitize the response. //The sanitized response should be returned dataFilter: empty &#125; 没有相关的参数可以设定 ajax请求 的 headers 参数。 继续搜索关键词 “ajaxSettings” 查找源码，可以看到以下内容： 12345678$.ajax = function(options)&#123; var settings = $.extend(&#123;&#125;, options || &#123;&#125;), deferred = $.Deferred &amp;&amp; $.Deferred(), urlAnchor, hashIndex for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key] ajaxStart(settings) ... 在执行 $.ajax 时会循环查找 ajaxSettings 的参数，当参数未定义时，会获取 $.ajaxSettings 相关属性的值，并使用 ajaxStart 方法设置参数。那么我们可以在参数中追加 $.ajaxSettings 属性。 第二种方法：1$.ajaxSettings.headers = &#123;'name' : 'value' &#125;; 或者：123$.ajaxSettings = $.extend($.ajaxSettings, &#123; headers: &#123;'name' : 'value' &#125;;&#125;);]]></content>
      <categories>
        <category>PHP</category>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[robots.txt详解]]></title>
    <url>%2F2017%2F08%2F08%2Frobots-txt%2F</url>
    <content type="text"><![CDATA[什么是robots.txt文件? robots.txt 文件是用来禁止搜索引擎收录的方法。原则上文件中不写禁止指令则为允许访问。 搜索引擎使用 spider程序 自动访问互联网上的网页并获取网页信息。 spider 在访问一个网站时，首先会检查该网站的根域下是否有一个叫做 robots.txt 的纯文本文件，这个文件用于指定 spider 在您网站上的抓取范围。您可以在您的网站中创建一个 robots.txt ，在文件中声明 该网站中不想被搜索引擎收录的部分或者指定搜索引擎只收录特定的部分。 请注意，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用 robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立 robots.txt 文件。 robots.txt文件放在哪里? robots.txt文件应该放置在 网站根目录 下。 meta标签简介meta标签中没有大小写之分，name=&quot;robots&quot; 表示所有的搜索引擎，content 部分有四个指令选项：index、noindex、follow、nofollow，指令间以 , 分隔。 index ：告诉搜索机器人抓取该页面，noindex 相反； follow：表示搜索机器人可以沿着该页面上的链接继续抓取下去，nofollow 相反； 缺省值是 index 和 follow 。 这样，一共有四种组合： 1234&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;&lt;meta name=&quot;robots&quot; content=&quot;noindex,follow&quot;&gt;&lt;meta name=&quot;robots&quot; content=&quot;index,nofollow&quot;&gt;&lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot;&gt; 其中1234&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;等同于 &lt;meta name=&quot;robots&quot; content=&quot;all&quot;&gt;&lt;meta name=&quot;robots&quot; content=&quot;noindex,nofollow&quot;&gt;等同于&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt; 注意：绝大多数的搜索引擎机器人都遵守robots.txt的规则，而对于Robots meta标签，目前支持的并不多。搜索引擎Google完全支持，还增加了一个指令“archive”，可以限制Google是否保留网页快照。 12&lt;!-- 表示抓取该站点中页面并沿着页面中链接抓取，但是不在Google上保留该页面的网页快照。--&gt;&lt;meta name=&quot;googlebot&quot; content=&quot;index,follow,noarchive&quot;&gt; 如何禁止跟踪网页的链接，而只对网页建索引？ 如果您不想搜索引擎追踪此网页上的链接，且不传递链接的权重，请将此元标记置入网页的 部分： 1&lt;meta name=&quot;robots&quot; content=&quot;index,nofollow&quot;&gt; 如果您不想百度追踪某一条 特定链接 ，百度还支持更精确的控制，请将此标记直接写在某条链接上： 1&lt;a href=&quot;signin.php&quot; rel=&quot;nofollow&quot;&gt;sign in&lt;/a&gt; 要允许其他搜索引擎跟踪，但 仅防止百度 跟踪您网页的链接，请将此元标记置入网页的 部分： 1&lt;meta name=&quot;Baiduspider&quot; content=&quot;index,nofollow&quot;&gt; 如何禁止在搜索结果中显示网页快照，而只对网页建索引？ 要防止 所有搜索引擎 显示您网站的快照，请将此元标记置入网页的部分： 1&lt;meta name=&quot;robots&quot; content=&quot;noarchive&quot;&gt; 要允许其他搜索引擎显示快照，但 仅防止百度显示 ，请使用以下标记： 1&lt;meta name=&quot;Baiduspider&quot; content=&quot;noarchive&quot;&gt; 注：此标记只是禁止百度显示该网页的快照，百度会继续为网页建索引，并在搜索结果中显示网页摘要。 robots.txt文件的格式注释在该文件中可以使用 # 进行注解，具体使用方法和UNIX中的惯例一样。 User-agent: 该项的值用于描述搜索引擎 robot 的名字。 如果有 多条User-agent记录 说明有 多个robot 会受到 “robots.txt” 的限制，对该文件来说，至少要有一条 User-agent 记录。 如果该项的值设为 * ，则对任何 robot 均有效， 如果在 “robots.txt” 文件中，加入 “User-agent:SomeBot” 和若干 Disallow 、 Allow 行，那么名为 “SomeBot” 只受到 “User-agent:SomeBot” 后面的 Disallow 和 Allow 行的限制。 Disallow: 该项的值用于描述不希望被访问的一组URL，这个值可以是一条完整的路径，也可以是路径的非空前缀，以Disallow项的值开头的URL不会被 robot 访问。例如：1、&quot;Disallow:/help&quot;：禁止robot访问/help.html、/helpabc.html、/help /index.html。2、&quot;Disallow:/help/&quot;：则允许robot访问/help.html、/helpabc.html，不能访问 /help/index.html。3、&quot;Disallow:&quot;：说明允许robot访问该网站的所有url。 在”/robots.txt”文件中，至少要有一 条Disallow记录。如果”/robots.txt”不存在或者为空文件，则对于所有的搜索引擎robot，该网站都是开放的。 Allow: 该项的值用于描述希望被访问的一组URL，与Disallow项相似，这个值可以是一条完整的路径，也可以是路径的前缀，以Allow项的值开头的URL是允许robot访问的。例如：&quot;Allow:/hibaidu&quot;：允许robot访问/hibaidu.htm、/hibaiducom.html、 /hibaidu/com.html。 一个网站的所有URL默认是Allow的，所以Allow通常与Disallow搭配使用，实现允许访问一部分网页 同时禁止访问其它所有URL的功能。 使用 “*“ 和 “$” ：Baiduspider支持使用通配符”*“和”$”来模糊匹配url。&quot;$&quot;： 匹配行结束符。&quot;*&quot;： 匹配0或多个任意字符。 请注意：区分您不想被抓取或收录的目录的大小写 用法举例 禁止所有 12User-agent: * Disallow: / 允许所有 12345User-agent: *Disallow: 或者User-agent: *Allow: / 禁止访问特定目录 1234User-agent: *Disallow: /cgi-bin/Disallow: /tmp/Disallow: /~joe/ 在这个例子中，该网站有三个目录对搜索引擎的访问做了限制，即robot不会访问这三个目录。需要注意的是对每一个目录必须分开声明，而不能写成 “Disallow: /cgi-bin/ /tmp/“。 允许访问特定目录 1234User-agent: *Allow: /cgi-bin/seeAllow: /tmp/hiAllow: /~joe/look 使用正则1、使用”*”限制访问url禁止访问 /cgi-bin/ 目录下的所有以&quot;.htm&quot;为后缀的URL(包含子目录)。 12User-agent: *Disallow: /cgi-bin/*.htm 2、使用&quot;$&quot;限制访问url仅允许访问以&quot;.htm&quot;为后缀的URL。 123User-agent: *Allow: .htm$Disallow: / 3、禁止访问网站中所有的动态页面 12User-agent: *Disallow: /*?* 4、禁止抓取图片仅允许抓取网页，禁止抓取任何图片。 123456User-agent: *Disallow: .jpg$Disallow: .jpeg$Disallow: .gif$Disallow: .png$Disallow: .bmp$ 5、允许抓取特定格式的图片允许抓取网页和gif格式图片，不允许抓取其他格式图片 123456User-agent: BaiduspiderAllow: .gif$Disallow: .jpg$Disallow: .jpeg$ Disallow: .png$Disallow: .bmp$ 6、禁止抓取特定格式的图片 12User-agent: BaiduspiderDisallow: .jpg$ 网站管理员工具Google提供了 robots.txt分析工具。它可以按照 Googlebot 读取 robots.txt 文件的相同方式读取该文件，并且可为 Google user-agents（如 Googlebot）提供结果。我们强烈建议您使用它。 误区误区一：我的网站上的所有文件都需要蜘蛛抓取，那我就没必要在添加robots.txt文件了。反正如果该文件不存在，所有的搜索蜘蛛将默认能够访问网站上所有没有被口令保护的页面。 每当用户试图访问某个不存在的URL时，服务器都会在日志中记录404错误（无法找到文件）。每当搜索蜘蛛来寻找并不存在的robots.txt文件时，服务器也将在日志中记录一条404错误，所以你应该做网站中添加一个robots.txt。* 误区二：在robots.txt文件中设置所有的文件都可以被搜索蜘蛛抓取，这样可以增加网站的收录率。 网站中的程序脚本、样式表等文件即使被蜘蛛收录，也不会增加网站的收录率，还只会浪费服务器资源。因此必须在robots.txt文件里设置不要让搜索蜘蛛索引这些文件。 误区三：搜索蜘蛛抓取网页太浪费服务器资源，在robots.txt文件设置所有的搜索蜘蛛都不能抓取全部的网页。 如果这样的话，会导致整个网站不能被搜索引擎收录。 使用技巧 每当用户试图访问某个不存在的URL时，服务器都会在日志中记录404错误（无法找到文件）。每当搜索蜘蛛来寻找并不存在的robots.txt文件时，服务器也将在日志中记录一条404错误，所以你应该在网站中添加一个robots.txt。 网站管理员必须使蜘蛛程序远离某些服务器上的目录 —— 保证服务器性能。比如：大多数网站服务器都有程序储存在“cgi-bin”目录下，因此在robots.txt文件中加入“Disallow: /cgi-bin”是个好主意，这样能够避免将所有程序文件被蜘蛛索引，可以节省服务器资源。一般网站中不需要蜘蛛抓取的文件有：后台管理文件、程序脚本、附件、数据库文件、编码文件、样式表文件、模板文件、导航图片和背景图片等等。 如果你的网站是动态网页，并且你为这些动态网页创建了静态副本，以供搜索蜘蛛更容易抓取。那么你需要在robots.txt文件里设置避免动态网页被蜘蛛索引，以保证这些网页不会被视为含重复内容。 robots.txt文件里还可以直接包括在sitemap文件的链接。就像这样： Sitemap: sitemap.xml 目前对此表示支持的搜索引擎公司有Google, Yahoo, Ask and MSN。而中文搜索引擎公司，显然不在这个圈子内。这样做的好处就是，站长不用到每个搜索引擎的站长工具或者相似的站长部分，去提交自己的sitemap文件，搜索引擎的蜘蛛自己就会抓取robots.txt文件，读取其中的sitemap路径，接着抓取其中相链接的网页。 合理使用robots.txt文件还能避免访问时出错。比如，不能让搜索者直接进入购物车页面。因为没有理由使购物车被收录，所以你可以在robots.txt文件里设置来阻止搜索者直接进入购物车页面。]]></content>
      <categories>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis CI自动持续化部署博客]]></title>
    <url>%2F2017%2F08%2F07%2Ftravis-ci-hexo%2F</url>
    <content type="text"><![CDATA[创建分支存储源代码在本地创建分支 hexo 来存储源代码，在根目录执行如下命令: 123456git initgit config user.name 'username'git config user.email 'username@email'git remote add origin `git@github.com:username/username.github.io.git`git commit -am "fix"git checkout -b 'hexo' 登录Travis CITravis CI官网，使用GitHub账户登录。登录完成后点击左侧仓库列表上面的 + 号，找到username.github.io 这个项目,并点击前面的开关,让其处于打开状态。 Github 生成 Personal access tokens点击个人头像右边的三角符号，选择 Setting ，在左侧找到 Personal access tokens， 点击按钮 Generate new token 生成新的token ，记录下生成的token，命名随意。 设置Travis CI使用token自动部署设置Travis CI中的项目，在GitHub中使用push命令时自动部署。 使用Github生成的 Personal access tokens在项目设置界面创建环境变量，命名为GH_TOKEN，值为在Github 生成 的Personal access token的值。 创建配置文件 .travis.yml在根目录创建文件.travis.yml，内容如下:1234567891011121314151617181920212223242526272829language: node_js #设置语言node_js: stable #设置相应的版本before_install:- npm install -g hexo-cli # 安装 hexoinstall: - npm install #安装hexo及插件script: - hexo clean #清除 - hexo g #生成after_script: - cd ./public - git init - git config user.name &quot;jeskinfly&quot; #修改name - git config user.email &quot;jeskinfly@163.com&quot; #修改email - git add . - git commit -m &quot;update&quot; - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master # GH_TOKEN是在Travis中配置token的名称branches: only: - hexo #只监测hexo分支，hexo是我的分支的名称，可根据自己情况设置env: global: - GH_REF: github.com/jeskinfly/jeskinfly.github.io.git #设置GH_REF，注意更改yourname]]></content>
      <categories>
        <category>Github</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取IP地址信息]]></title>
    <url>%2F2017%2F08%2F02%2Fapi-ip%2F</url>
    <content type="text"><![CDATA[介绍目前主要的解析方式有两种：通过API，或通过IP数据库。 API优点1、编码简单，通过请求获得数据（通常是json数据）2、而且不用维护数据库，对本地没有负担。 缺点1、有并发限制。每秒只能发几条2、上限限制。每天请求不超过一个上限。3、地址可能面临变更。 本地数据优点1、数据存储在本地，只有硬件限制。2、可以获取任意格式。3、可以随时取随时用。缺点1、需要编程解析数据。2、需要维护数据。3、需要考虑服务器负载。 提示 : 前期开发可用API查询,并缓存查询的IP信息,后期根据请求的实际情况使用纯真数据库或GEOIP数据库在本地获取位置信息 淘宝IP地址库提供的服务包括：1、根据用户提供的IP地址，快速查询出该IP地址所在的地理信息和地理相关的信息，包括国家、省、市和运营商。2、用户可以根据自己所在的位置和使用的IP地址更新我们的服务内容。 优势 :1、提供国家、省、市、县、运营商全方位信息，信息维度广，格式规范。2、提供完善的统计分析报表，省准确度超过99.8%，市准确度超过96.8%，数据质量有保障。 示例 : 12$ip = @file_get_contents("http://ip.taobao.com/service/getIpInfo.php?ip=".$_GET["ip"]);$ip = json_decode($ip,true); 新浪IP API新浪这个应该说是最好的。可以根据请求参数 format 自定义数据格式（默认为纯文本格式，format 的可选参数js ，json。下面列举的是 js 的格式）。 示例 : 12$ip = @file_get_contents("http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&amp;ip=".$_GET["ip"]);echo $ip; 返回值数据格式： 1var remote_ip_info = &#123;“ret”:1,”start”:”59.37.164.179″,”end”:”59.37.165.17″,”country”:”\u4e2d\u56fd”,”province”:”\u5e7f\u4e1c”,”city”:”\u6c5f\u95e8″,”district”:””,”isp”:”\u7535\u4fe1″,”type”:””,”desc”:””&#125;; 126 IP API126提供的这个功能方面不如新浪但是数据相对来说是比较准确的。 示例 : 12$ip = @file_get_contents("http://ip.ws.126.net/ipquery?ip=".$_GET["ip"]);echo $ip; 返回值数据格式： 1var lo=&quot;北京市&quot;, lc=&quot;朝阳区&quot;; var localAddress=&#123;city:&quot;朝阳区&quot;, province:&quot;北京市&quot;&#125;; 腾讯位置服务 腾讯支持数据格式 JSON, JSONP方式返回, 支持 http 和 https 协议 。 使用限制1、 需申请开发者密钥Key2、日调用量：10,000 次/接口/Key3、并发限制：5 次/秒/接口/Key 超过日调用量和并发数的开发者，可通过以下途径解决： 对于多频次的相同请求，可通过缓存结果，并定时访问更新的方式，减少对在线服务调用的依赖； 地址 1http://apis.map.qq.com/ws/location/v1/ip 请求参数 参数 必填 说明 示例 p 否 IP地址，缺省时会使用请求端的IP ip=202.106.0.20 ey 是 开发密钥（Key） key=OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77 utput 否 返回格式：支持JSON/JSONP，默认JSON output=json allback 否 JSONP方式回调函数 callback=function1 123456789101112131415161718192021//响应示例：&#123; "status": 0, // 状态码，0为正常, // 310 请求参数信息有误， // 311 Key格式错误, // 306 请求有护持信息请检查字符串, // 110 请求来源未被授权 "message": "query ok", // 状态说明 "result": &#123; "location": &#123; "lng": 116.407526, // 纬度 "lat": 39.90403 // 经度 &#125;, "ad_info": &#123; "nation": "中国", // 国家 "province": "", // 省 "city": "", // 市 "adcode": 110000 // 行政区划代码 &#125; &#125;&#125; 百度IP定位使用以及限制与腾讯基本相同，此处不作详细介绍，请移步官方查看文档：百度IP定位 GEOIPGeoIP IP智能系列产品分类 :1、 API接口服务。 GeoIP根据IP返回的地址信息。2、 从本地获取位置信息。提供网络查询免费开源IP数据库下载。直达GitHub仓库PHP版本( 包含 mmdb 格式的IP数据库 ) 直达官网链接 GEOIP 纯真IP数据库下载并安装软件，查找安装目录的文件 qqwry.dat ,可转换为数据库文件或通过类库解析使用。实际IP地址一般为二进制: 01010101.10101010.00110011.11001100。直达链接 纯真dat文件解压为txt查看内容123450.0.0.0 0.255.255.255 IANA保留地址1.0.0.0 1.0.0.255 澳大利亚 亚太互联网信息中心1.0.1.0 1.0.3.255 福建省 电信1.0.4.0 1.0.7.255 澳大利亚 墨尔本Big Red集团1.0.8.0 1.0.15.255 广东省电信 每行三个字段，start, end, address，从start到end之间的IP都是address这个位置。因为end跟下一个start是连接的，所以只需要记录start: address就好了，可通过查找“小于等于给定IP的最大值”来获取地址。参考链接 :解析纯真IP地址库 注：如果每一条ip对应一个address ，把所有ip的address写成一个列表？那么服务器得有200G来存放。]]></content>
      <categories>
        <category>PHP</category>
        <category>IP</category>
      </categories>
      <tags>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP OPcache 性能加速]]></title>
    <url>%2F2017%2F08%2F01%2Fphp-opcache%2F</url>
    <content type="text"><![CDATA[简介 OPcache 通过将 PHP 脚本预编译的字节码存储到共享内存中来提升 PHP 的性能， 存储预编译字节码的好处就是 省去了每次加载和解析 PHP 脚本的开销。 PHP 5.5.0 及后续版本中已经绑定了 OPcache 扩展。 对于 PHP 5.2，5.3 和 5.4 版本可以使用 » PECL 扩展中的 OPcache 库。 安装PHP 5.5.0 及后续版本 编辑 PHP 配置文件 php.ini, 取消对应的 zend_extension 前的注释 ( 删除前面的; ) 在 非 Windows 平台使用 zend_extension=/full/path/to/opcache.so， Windows 平台使用 zend_extension=C:\path\to\php_opcache.dll。 PHP 5.2, 5.3 和 5.4 版本升级PHP版本到5.5或以上 或 手动安装此 PECL 扩展。 配置Opcache的推荐配置:123456789zend_extension=opcache.so // 非Windows平台开启扩展opcache.enable_cli=1opcache.memory_consumption=128 // 共享内存大小, 这个根据你们的需求可调opcache.interned_strings_buffer=8 // interned string的内存大小, 也可调opcache.max_accelerated_files=4000 // 最大缓存的文件数目opcache.revalidate_freq=60 // 60s检查一次文件更新opcache.fast_shutdown=1 // 打开快速关闭, 打开的时候, 回收内存的速度会提高opcache.save_comments=0 // 不保存文件/函数的注释 重启服务器重启服务器apache或Nginx即可 小提示 1、不建议在开发过程中开启 Opcache。 2、如果在更新代码之后，发现没有执行的还是旧代码，可使用函数 opcache_reset() 来清除缓存。该函数将重置整个字节码缓存。 在调用 opcache_reset() 之后，所有的脚本将会重新载入并且在下次被点击的时候重新解析。 3、通过图像查看各项指标和管理 OPcache , 可通过 Github 开源项目 PeeHaa/OpCacheGUI;]]></content>
      <categories>
        <category>PHP</category>
        <category>性能</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel安装homestead要注意的几个问题]]></title>
    <url>%2F2017%2F07%2F31%2Flaravel-homestead%2F</url>
    <content type="text"><![CDATA[安装时网络问题 国内因为网络的原因，默认的盒子安装命令 vagrant box add laravel/homestead 变得不适用。可以先下载到本地后通过本地安装。注意，请勿使用迅雷离线下载，亲测下载后的文件会损坏。 获取下载链接 执行命令vagrant box add laravel/homestead后会出来三个选项，选择virtualbox后出现在Downloading后的地址为下载链接。123456789101112131415$ vagrant box add laravel/homestead==&gt; box: Loading metadata for box 'laravel/homestead' box: URL: https://atlas.hashicorp.com/laravel/homesteadThis box can work with multiple providers! The providers that itcan work with are listed below. Please review the list and choosethe provider you will be working with.1) parallels2) virtualbox3) vmware_desktop$ Enter your choice: 2==&gt; box: Adding box 'laravel/homestead' (v2.0.0) for provider: virtualbox box: Downloading: https://vagrantcloud.com/laravel/boxes/homestead/versions/2.0.0/providers/virtualbox.box box: Progress: 0% (Rate: 75458/s, Estimated time remaining: 9:56:08)==&gt; box: Waiting for cleanup before exiting... 此处下载地址为:https://vagrantcloud.com/laravel/boxes/homestead/versions/2.0.0/providers/virtualbox.box 从本地安装 假设把下载下来的box命名为homestead-virtualbox-2.0.0.box，可以使用以下方法导入.box 文件： 1、在 .box 的同文件夹下创建一个 metadata.json 文件。json文件命名是随便的,此文件在后面的命令行中会用到。内容为以下:123456789101112131415&#123; "name": "laravel/homestead", "versions": [ &#123; "version": "2.0.0", "providers": [ &#123; "name": "virtualbox", "url": "homestead-virtualbox-2.0.0.box" // eg. "url": "file:///e:/boxes/homestead-virtualbox-2.0.0.box" &#125; ] &#125; ]&#125; 字段说明: version - 可以指定当前盒子导入的版本标示； url - 支持 绝对文件路径 和 相对文件路径 如 “url”: “file:///e:/boxes/homestead-virtualbox-2.0.0.box” 2、运行以下命令导入，使用新建的json文件导入盒子：1vagrant box add metadata.json 3、运行 list 命令查看是否添加成功：1vagrant box list 执行 vagrant up 报错执行 vagrant up 报错 The requested address is not valid12345678$ vagrant upBringing machine 'homestead-7' up with 'virtualbox' provider...==&gt; homestead-72: Importing base box 'laravel/homestead2'...==&gt; homestead-72: Matching MAC address for NAT networking...==&gt; homestead-72: Checking if box 'laravel/homestead2' is up to date...==&gt; homestead-72: Setting the name of the VM: homestead-72==&gt; homestead-72: Destroying VM and associated drives...C:/HashiCorp/Vagrant/embedded/gems/gems/vagrant-1.9.3/lib/vagrant/util/is_port_open.rb:21:in `initialize': The requested address is not valid in its context. - connect(2) for "0.0.0.0" port 8000 (Errno::EADDRNOTAVAIL) 默认会绑定所有IP就是提示里面的 0.0.0.0 ，改成只是我本地和虚拟机的转发。 对于Laravel的HomeStead，修改文件 ./scripts/homestead.rb 的网络配置1234567891011# Use Default Port Forwarding Unless Overriddenunless settings.has_key?("default_ports") &amp;&amp; settings["default_ports"] == false default_ports.each do |guest, host| unless settings["ports"].any? &#123; |mapping| mapping["guest"] == guest &#125; # 原来的 # config.vm.network "forwarded_port", guest: guest, host: host, auto_correct: true, host_ip: '0.0.0.0' # 修改后 config.vm.network "forwarded_port", guest: guest, host: host, auto_correct: true, host_ip: '127.0.0.1' end endend 对于CentOS，修改Vagrantfile文件12# config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8888config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8888, host_ip: &quot;127.0.0.1&quot;, protcol: &quot;tcp&quot; 其他端口转发，可举一反三。 自定义虚拟机的名称1234567891011config.vm.provider "virtualbox" do |vb| # add a line # Define this vm's name vb.name = "centos_7" # 自定义在虚拟机中显示的名称 # # Display the VirtualBox GUI when booting the machine # vb.gui = true # # # Customize the amount of memory on the VM: # vb.memory = "1024" end 同步读取慢（不建议） Vagrant 默认通过 vagrantfile 执行同步，并可以很好的执行。但是如果不满意同步的速度，windows 可以也使用 rsync，但是不建议。 window7 下使用rsync，可解决vagrant 共享目录读取速度慢的问题，采用的是一次性单向同步，只在执行 vagrant up 或 vagrant reload时同步一次。 修改宿主机上的文件后，可以结合 vagrant rsync and vagrant rsync-auto进行手动同步。在 Vagrantfile 文件中设置同步目录为 rsync。1config.vm.synced_folder ".", "/vagrant", type: "rsync", rsync__auto: true 下载安装 Cygwin 或 MinGW ，然后查找出 rsync 安装。 把 rsync.exe 的路径加入 windows的 path 环境。 执行 vagrant reload ，现在可以享受 windows下的vbox极速共享目录了。 FTP或SFTP提交代码配置虚拟机，在vagrantfile中添加如下内容1234567891011121314151617config.push.define &quot;ftp&quot; do |push| # host:port，端口可以省略，默认端口 22 push.host = &quot;ftp.company.com&quot; push.username = &quot;username&quot; push.password = &quot;password&quot; # true：SFTP；false：FTP。默认false。 push.secure = false # 指定通过(S)FTP上传文件到哪个目录（默认为 / ）。 push.destination = &apos;/&apos; # 排除的文件,可以多次配置,push.dir的相对路径 push.exclude = &apos;exclude.file.1&apos; push.exclude = &apos;exclude.file.2&apos; push.exclude = &apos;exclude.file.*&apos; # 把虚拟机哪个目录上传上去,默认虚拟机中Vagrantfile所在的目录。 # 如: 通过Box安装的CentOS和HomeStead中，Vagrantfile所在的目录为/vagrant; push.dir = &apos;/src&apos;end 然后执行 vagrant push。]]></content>
      <categories>
        <category>PHP</category>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码散列]]></title>
    <url>%2F2017%2F07%2F31%2Fphp-Hash%2F</url>
    <content type="text"><![CDATA[前言 PHP的 MD5，SHA1 以及 SHA256 这样的散列算法是面向快速、高效 进行散列处理而设计的。随着技术进步和计算机硬件的提升， 破解者可以使用“暴力”方式来寻找散列码 所对应的原始数据。 因为现代化计算机可以快速的“反转”上述散列算法的散列值， 所以很多安全专家都强烈建议 不要在密码散列中使用这些散列算法**。 如何对密码进行散列处理？ 当进行密码散列处理的时候，有两个必须考虑的因素： 计算量以及“盐”。 散列算法的计算量越大， 暴力破解所需的时间就越长。 PHP 5.5 提供了 一个原生密码散列 API， 它提供一种安全的方式来完成密码 散列和 验证。 PHP 5.3.7 及后续版本中都提供了一个 » 纯 PHP 的兼容库。 password_hash() 是 crypt() 的一个简单封装，采用 Blowfish算法 ，并且完全与现有的密码哈希兼容。推荐使用 password_hash() 。 时序攻击 如果使用 crypt() 函数来进行密码验证， 那么你需要选择一种耗时恒定的字符串比较算法来避免时序攻击。 （译注：就是说，字符串比较所消耗的时间恒定， 不随输入数据的多少变化而变化） PHP 中的 == 和 === 操作符 和 strcmp() 函数都不是耗时恒定的字符串比较，但是 password_verify() 可以帮你完成这项工作。 加盐 “加盐”是指在进行散列处理的过程中 加入的一些数据，用来避免从已计算的散列值表 （被称作“彩虹表”）中 对比输出数据从而获取明文密码的风险。 如果不提供“盐”，password_hash() 函数会随机生成“盐”。 非常简单，行之有效。 验证 PHP当使用 password_hash() 或者 crypt() 函数时， “盐”会被作为生成的散列值的一部分返回。 你可以直接把完整的返回值存储到数据库中， 因为这个返回值中已经包含了足够的信息， 可以直接用在 password_verify() 或 crypt() 函数来进行密码验证。 下图展示了 crypt() 或 password_hash() 函数返回值的结构。 如你所见，算法的信息以及“盐”都已经包含在返回值中， 在后续的密码验证中将会用到这些信息。 原生密码散列 API密码散列算法函数 password_hash — 创建密码的哈希（hash） password_needs_rehash — Checks if the given hash matches the given options password_verify — 验证密码是否和哈希匹配 password_hash() 使用了一个强的哈希算法，来产生足够强的盐值，并且会自动进行合适的轮次。Note: 由于 crypt() 使用的是单向算法，因此不存在 decrypt 函数。 password_hash(PHP 5 &gt;= 5.5.0, PHP 7)password_hash — 创建密码的哈希（hash）string password_hash ( string $password , integer $algo [, array $options ] ) $password : 用户的密码。注意： 使用 PASSWORD_BCRYPT 做算法，将使 password 参数最长为72个字符，超过会被截断。 $algo : 支持的算法 : PASSWORD_DEFAULT - 使用 bcrypt 算法 (PHP 5.5.0 默认)。 注意，该常量会随着 PHP 加入更新更高强度的算法而改变。所以，使用此常量生成结果的长度将在未来有变化。 因此，数据库里储存结果的列可超过60个字符（最好是255个字符）。 PASSWORD_BCRYPT - 使用 CRYPT_BLOWFISH 算法创建哈希。 这会产生兼容使用 &quot;$2y$&quot; 的 crypt()。 结果将会是 60 个字符的字符串， 或者在失败时返回 FALSE 。默认算法。 $options: 支持的选项： salt - 在散列密码时加的盐（干扰字符串）。省略此值后，password_hash() 会为每个密码哈希自动生成随机的盐值。强烈建议不要自己为这个函数生成盐值（salt）。只要不设置，它会自动创建安全的盐值。盐值（salt）选项从 PHP 7.0.0 开始被废弃（deprecated）了。 现在最好选择简单的使用默认产生的盐值。 cost - 用来指明算法递归的层数。默认值是 10。 password_verify(PHP 5 &gt;= 5.5.0, PHP 7)password_verify — 验证密码是否和哈希匹配boolean password_verify ( string $password , string $hash ) $password: 用户的密码。使用hash算法加密前的原始密码。 $hash 一个由 password_hash() 创建的散列值。 其他password_needs_rehash加强安全性，如何在验证密码后更新hash密码？。12345678910111213141516171819$password = 'rasmuslerdorf';$hash = '$2y$10$YCFsG6elYca568hBi2pZ0.3LDL5wjgxct1N8w/oLR/jfHsiQwCqTS';// The cost parameter can change over time as hardware improves$options = array('cost' =&gt; 11);// Verify stored hash against plain-text passwordif (password_verify($password, $hash)) &#123; // Check if a newer hashing algorithm is available // or the cost has changed if (password_needs_rehash($hash, PASSWORD_DEFAULT, $options)) &#123; // If so, create a new hash, and replace the old one $newHash = password_hash($password, PASSWORD_DEFAULT, $options); // todo: store newHash to database &#125; // Log user in&#125; 纯 PHP 的兼容库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294/** * A Compatibility library with PHP 5.5's simplified password hashing API. * * @author Anthony Ferrara &lt;ircmaxell@php.net&gt; * @license http://www.opensource.org/licenses/mit-license.html MIT License * @copyright 2012 The Authors */namespace &#123; if (!defined('PASSWORD_BCRYPT')) &#123; /** * PHPUnit Process isolation caches constants, but not function declarations. * So we need to check if the constants are defined separately from * the functions to enable supporting process isolation in userland * code. */ define('PASSWORD_BCRYPT', 1); define('PASSWORD_DEFAULT', PASSWORD_BCRYPT); define('PASSWORD_BCRYPT_DEFAULT_COST', 10); &#125; if (!function_exists('password_hash')) &#123; /** * Hash the password using the specified algorithm * * @param string $password The password to hash * @param int $algo The algorithm to use (Defined by PASSWORD_* constants) * @param array $options The options for the algorithm to use * * @return string|false The hashed password, or false on error. */ function password_hash($password, $algo, array $options = array()) &#123; if (!function_exists('crypt')) &#123; trigger_error("Crypt must be loaded for password_hash to function", E_USER_WARNING); return null; &#125; if (is_null($password) || is_int($password)) &#123; $password = (string) $password; &#125; if (!is_string($password)) &#123; trigger_error("password_hash(): Password must be a string", E_USER_WARNING); return null; &#125; if (!is_int($algo)) &#123; trigger_error("password_hash() expects parameter 2 to be long, " . gettype($algo) . " given", E_USER_WARNING); return null; &#125; $resultLength = 0; switch ($algo) &#123; case PASSWORD_BCRYPT: $cost = PASSWORD_BCRYPT_DEFAULT_COST; if (isset($options['cost'])) &#123; $cost = (int) $options['cost']; if ($cost &lt; 4 || $cost &gt; 31) &#123; trigger_error(sprintf("password_hash(): Invalid bcrypt cost parameter specified: %d", $cost), E_USER_WARNING); return null; &#125; &#125; // The length of salt to generate $raw_salt_len = 16; // The length required in the final serialization $required_salt_len = 22; $hash_format = sprintf("$2y$%02d$", $cost); // The expected length of the final crypt() output $resultLength = 60; break; default: trigger_error(sprintf("password_hash(): Unknown password hashing algorithm: %s", $algo), E_USER_WARNING); return null; &#125; $salt_req_encoding = false; if (isset($options['salt'])) &#123; switch (gettype($options['salt'])) &#123; case 'NULL': case 'boolean': case 'integer': case 'double': case 'string': $salt = (string) $options['salt']; break; case 'object': if (method_exists($options['salt'], '__tostring')) &#123; $salt = (string) $options['salt']; break; &#125; case 'array': case 'resource': default: trigger_error('password_hash(): Non-string salt parameter supplied', E_USER_WARNING); return null; &#125; if (PasswordCompat\binary\_strlen($salt) &lt; $required_salt_len) &#123; trigger_error(sprintf("password_hash(): Provided salt is too short: %d expecting %d", PasswordCompat\binary\_strlen($salt), $required_salt_len), E_USER_WARNING); return null; &#125; elseif (0 == preg_match('#^[a-zA-Z0-9./]+$#D', $salt)) &#123; $salt_req_encoding = true; &#125; &#125; else &#123; $buffer = ''; $buffer_valid = false; if (function_exists('mcrypt_create_iv') &amp;&amp; !defined('PHALANGER')) &#123; $buffer = mcrypt_create_iv($raw_salt_len, MCRYPT_DEV_URANDOM); if ($buffer) &#123; $buffer_valid = true; &#125; &#125; if (!$buffer_valid &amp;&amp; function_exists('openssl_random_pseudo_bytes')) &#123; $strong = false; $buffer = openssl_random_pseudo_bytes($raw_salt_len, $strong); if ($buffer &amp;&amp; $strong) &#123; $buffer_valid = true; &#125; &#125; if (!$buffer_valid &amp;&amp; @is_readable('/dev/urandom')) &#123; $file = fopen('/dev/urandom', 'r'); $read = 0; $local_buffer = ''; while ($read &lt; $raw_salt_len) &#123; $local_buffer .= fread($file, $raw_salt_len - $read); $read = PasswordCompat\binary\_strlen($local_buffer); &#125; fclose($file); if ($read &gt;= $raw_salt_len) &#123; $buffer_valid = true; &#125; $buffer = str_pad($buffer, $raw_salt_len, "\0") ^ str_pad($local_buffer, $raw_salt_len, "\0"); &#125; if (!$buffer_valid || PasswordCompat\binary\_strlen($buffer) &lt; $raw_salt_len) &#123; $buffer_length = PasswordCompat\binary\_strlen($buffer); for ($i = 0; $i &lt; $raw_salt_len; $i++) &#123; if ($i &lt; $buffer_length) &#123; $buffer[$i] = $buffer[$i] ^ chr(mt_rand(0, 255)); &#125; else &#123; $buffer .= chr(mt_rand(0, 255)); &#125; &#125; &#125; $salt = $buffer; $salt_req_encoding = true; &#125; if ($salt_req_encoding) &#123; // encode string with the Base64 variant used by crypt $base64_digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; $bcrypt64_digits = './ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; $base64_string = base64_encode($salt); $salt = strtr(rtrim($base64_string, '='), $base64_digits, $bcrypt64_digits); &#125; $salt = PasswordCompat\binary\_substr($salt, 0, $required_salt_len); $hash = $hash_format . $salt; $ret = crypt($password, $hash); if (!is_string($ret) || PasswordCompat\binary\_strlen($ret) != $resultLength) &#123; return false; &#125; return $ret; &#125; /** * Get information about the password hash. Returns an array of the information * that was used to generate the password hash. * * array( * 'algo' =&gt; 1, * 'algoName' =&gt; 'bcrypt', * 'options' =&gt; array( * 'cost' =&gt; PASSWORD_BCRYPT_DEFAULT_COST, * ), * ) * * @param string $hash The password hash to extract info from * * @return array The array of information about the hash. */ function password_get_info($hash) &#123; $return = array( 'algo' =&gt; 0, 'algoName' =&gt; 'unknown', 'options' =&gt; array(), ); if (PasswordCompat\binary\_substr($hash, 0, 4) == '$2y$' &amp;&amp; PasswordCompat\binary\_strlen($hash) == 60) &#123; $return['algo'] = PASSWORD_BCRYPT; $return['algoName'] = 'bcrypt'; list($cost) = sscanf($hash, "$2y$%d$"); $return['options']['cost'] = $cost; &#125; return $return; &#125; /** * Determine if the password hash needs to be rehashed according to the options provided * * If the answer is true, after validating the password using password_verify, rehash it. * * @param string $hash The hash to test * @param int $algo The algorithm used for new password hashes * @param array $options The options array passed to password_hash * * @return boolean True if the password needs to be rehashed. */ function password_needs_rehash($hash, $algo, array $options = array()) &#123; $info = password_get_info($hash); if ($info['algo'] !== (int) $algo) &#123; return true; &#125; switch ($algo) &#123; case PASSWORD_BCRYPT: $cost = isset($options['cost']) ? (int) $options['cost'] : PASSWORD_BCRYPT_DEFAULT_COST; if ($cost !== $info['options']['cost']) &#123; return true; &#125; break; &#125; return false; &#125; /** * Verify a password against a hash using a timing attack resistant approach * * @param string $password The password to verify * @param string $hash The hash to verify against * * @return boolean If the password matches the hash */ function password_verify($password, $hash) &#123; if (!function_exists('crypt')) &#123; trigger_error("Crypt must be loaded for password_verify to function", E_USER_WARNING); return false; &#125; $ret = crypt($password, $hash); if (!is_string($ret) || PasswordCompat\binary\_strlen($ret) != PasswordCompat\binary\_strlen($hash) || PasswordCompat\binary\_strlen($ret) &lt;= 13) &#123; return false; &#125; $status = 0; for ($i = 0; $i &lt; PasswordCompat\binary\_strlen($ret); $i++) &#123; $status |= (ord($ret[$i]) ^ ord($hash[$i])); &#125; return $status === 0; &#125; &#125;&#125;namespace PasswordCompat\binary &#123; if (!function_exists('PasswordCompat\\binary\\_strlen')) &#123; /** * Count the number of bytes in a string * * We cannot simply use strlen() for this, because it might be overwritten by the mbstring extension. * In this case, strlen() will count the number of *characters* based on the internal encoding. A * sequence of bytes might be regarded as a single multibyte character. * * @param string $binary_string The input string * * @internal * @return int The number of bytes */ function _strlen($binary_string) &#123; if (function_exists('mb_strlen')) &#123; return mb_strlen($binary_string, '8bit'); &#125; return strlen($binary_string); &#125; /** * Get a substring based on byte limits * * @see _strlen() * * @param string $binary_string The input string * @param int $start * @param int $length * * @internal * @return string The substring */ function _substr($binary_string, $start, $length) &#123; if (function_exists('mb_substr')) &#123; return mb_substr($binary_string, $start, $length, '8bit'); &#125; return substr($binary_string, $start, $length); &#125; /** * Check if current PHP version is compatible with the library * * @return boolean the check result */ function check() &#123; static $pass = NULL; if (is_null($pass)) &#123; if (function_exists('crypt')) &#123; $hash = '$2y$04$usesomesillystringfore7hnbRJHxXVLeakoG8K30oukPsA.ztMG'; $test = crypt("password", $hash); $pass = $test == $hash; &#125; else &#123; $pass = false; &#125; &#125; return $pass; &#125; &#125;&#125; 合适的 cost 值在交互的系统上，推荐在自己的服务器上测试此函数，调整 cost 参数直至函数时间开销小于 100 毫秒（milliseconds） 1234567891011121314151617181920/** * 这个例子对服务器做了基准测试（benchmark），检测服务器能承受多高的 cost * 在不明显拖慢服务器的情况下可以设置最高的值 * 8-10 是个不错的底线，在服务器够快的情况下，越高越好。 * 以下代码目标为 ≤ 50 毫秒（milliseconds）， * 适合系统处理交互登录。 */$timeTarget = 0.05; // 50 毫秒（milliseconds） $cost = 8;do &#123; $cost++; $start = microtime(true); password_hash("test", PASSWORD_BCRYPT, ["cost" =&gt; $cost]); $end = microtime(true);&#125; while (($end - $start) &lt; $timeTarget);echo "Appropriate Cost Found: " . $cost . "\n";?&gt; 手动设置盐值1234567891011121314/** * 注意，这里的盐值是随机产生的。 * 永远都不要使用固定盐值，或者不是随机生成的盐值。 * * 绝大多数情况下，可以让 password_hash generate 为你自动产生随机盐值 */$options = [ 'cost' =&gt; 11, // &lt;=7.1.0 mcrypt_create_iv; // &gt; 7.1.0 random_bytes(); 'salt' =&gt; bin2hex(mcrypt_create_iv(22, MCRYPT_DEV_URANDOM)),];echo password_hash("rasmuslerdorf", PASSWORD_BCRYPT, $options)."\n";?&gt;]]></content>
      <categories>
        <category>PHP</category>
        <category>加密</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合理编写JavaScript]]></title>
    <url>%2F2017%2F07%2F28%2Fjavacript-style-guide%2F</url>
    <content type="text"><![CDATA[类型原始值存取直接作用于它自身。 string number boolean null undefined 12345var foo = 1;var bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 复杂类型存取时作用于它自身值的引用。 object array function 12345var foo = [1, 2];var bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 单引号12345// badvar name = "Bob Parr";// goodvar name = 'Bob Parr'; 函数函数表达式1234567891011121314// 匿名函数表达式var anonymous = function() &#123; return true;&#125;;// 命名函数表达式var named = function named() &#123; return true;&#125;;// 立即调用的函数表达式（IIFE）(function () &#123; console.log('Welcome to the Internet. Please follow me.');&#125;()); 永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。 1234567891011121314// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodvar test;if (currentUser) &#123; test = function test() &#123; console.log('Yup.'); &#125;;&#125; 数组拷贝拷贝数组时，使用 Array#slice 1234567891011var len = items.length;var itemsCopy = [];var i;// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// gooditemsCopy = items.slice(); 对象访问属性通过变量访问属性时使用中括号 []12345678910var luke = &#123; jedi: true, age: 28&#125;;function getProp(prop) &#123; return luke[prop];&#125;var isJedi = getProp('jedi'); 判断比较运算符 &amp; 等号 优先使用 === 和 !== 而不是 == 和 !=. 条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则： 对象 被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值​ 数字 如果是 +0、-0 或 NaN 被计算为 false，否则为 true 字符串 如果是空字符串 ‘’ 被计算为 false，否则为 true 空格缩进使用 2 个空格作为缩进。 1234567891011121314// badfunction () &#123;∙∙∙∙var name;&#125;// badfunction () &#123;∙var name;&#125;// goodfunction () &#123;∙∙var name;&#125; 提升变量声明变量声明会提升至作用域顶部，但赋值不会。 1234// 我们知道这样不能正常工作（假设这里没有名为 notDefined 的全局变量）function example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125; 12345678910111213// 但由于变量声明提升的原因，在一个变量引用后再创建它的变量声明将可以正常工作。// 注：变量赋值为 true 不会提升。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// 解释器会把变量声明提升到作用域顶部，意味着我们的例子将被重写成：function example() &#123; var declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125; 匿名函数表达式匿名函数表达式会提升它们的变量名，但不会提升函数的赋值。 1234567function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function () &#123; console.log('anonymous function expression'); &#125;;&#125; 命名函数表达式命名函数表达式会提升变量名，但不会提升函数名或函数体。 12345678function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log('Flying'); &#125;;&#125; 12345678// 当函数名跟变量名一样时，表现也是如此。function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log('named'); &#125;&#125; 函数声明函数声明提升它们的名字和函数体。 123456function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125; 逗号 额外的行末逗号：不需要。这样做会在 IE6/7 和 IE9 怪异模式下引起问题。同样，多余的逗号在某些 ES3 的实现里会增加数组的长度。在 ES5 中已经澄清了 123456789101112131415161718192021// badvar hero = &#123; firstName: 'Kevin', lastName: 'Flynn',&#125;;var heroes = [ 'Batman', 'Superman',];// goodvar hero = &#123; firstName: 'Kevin', lastName: 'Flynn'&#125;;var heroes = [ 'Batman', 'Superman']; 分号使用分号。 1234;(function () &#123; var name = 'Skywalker'; return name;&#125;)(); 构造函数为原型追加方法给对象原型分配方法，而不是使用一个新对象覆盖原型。覆盖原型将导致继承出现问题：重设原型将覆盖原有原型！ 1234567891011121314151617181920212223function Jedi() &#123; console.log(&apos;new jedi&apos;);&#125;// badJedi.prototype = &#123; fight: function fight() &#123; console.log(&apos;fighting&apos;); &#125;, block: function block() &#123; console.log(&apos;blocking&apos;); &#125;&#125;;// goodJedi.prototype.fight = function fight() &#123; console.log(&apos;fighting&apos;);&#125;;Jedi.prototype.block = function block() &#123; console.log(&apos;blocking&apos;);&#125;; 方法链方法可以返回 this 来实现方法链式使用。 1234567891011121314151617181920212223242526272829// badJedi.prototype.jump = function jump() &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function setHeight(height) &#123; this.height = height;&#125;;var luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodJedi.prototype.jump = function jump() &#123; this.jumping = true; return this;&#125;;Jedi.prototype.setHeight = function setHeight(height) &#123; this.height = height; return this;&#125;;var luke = new Jedi();luke.jump() .setHeight(20); 变量名使用 $ 作为存储 jQuery 对象的变量名前缀。12345// badvar sidebar = $('.sidebar');// goodvar $sidebar = $('.sidebar');]]></content>
      <categories>
        <category>javascript</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Github + MarkDown + Subdomain 搭建博客]]></title>
    <url>%2F2017%2F07%2F07%2Fhexo%2F</url>
    <content type="text"><![CDATA[安装NodeJs下载及安装 菜鸟教程 – Node.js 安装配置 安装Git下载及安装 Git for Windows : git-scm 或 Git for Windows : git-github 。 初次运行 Git 前的配置 12345678// 全局配置$ git config --global user.name "USER NAME"$ git config --global user.email "USER EMAIL"// 配置具体项目，不带参数“--global”$ cd project$ git config user.name "USER NAME"$ git config user.email "USER EMAIL" SSH配置(公钥登录) 公钥登录：用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。 首先，你需要确认自己是否已经拥有密钥。默认情况下，用户的 SSH密钥 存储在其 ~/.ssh 目录下。其中一个带有 .pub 扩展名。 .pub文件是你的公钥，另一个则是私钥。如果找不到这样的文件（或者根本没有 .ssh 目录），你可以通过运行 ssh-keygen 程序来创建它们.在 Linux/Mac 系统中，ssh-keygen 随 SSH 软件包(openssh)提供；在 Windows 上，该程序包含于 MSysGit 软件包中。 确认是否有密钥1234$ cd ~/.ssh$ lsauthorized_keys2 id_dsa known_hostsconfig id_dsa.pub 生成SSH key: ssh-keygen12345678910111213$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"// -C : comment 注释// -t : type 加密方式，包括 dsa | ecdsa | ed25519 | rsa | rsa1// -b : 加密字符串的长度Generating public/private rsa key pair.Enter file in which to save the key (/home/schacon/.ssh/id_rsa):Created directory '/home/schacon/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/schacon/.ssh/id_rsa.Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.The key fingerprint is:d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local 首先 ssh-keygen 会确认密钥的存储位置（默认是 .ssh/id_rsa），然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。 发送密钥到服务器 现在，需要将公钥~/.ssh/id_rsa.pub里面的内容发送给服务器。 如果是使用 github 或 gitlab ，可以通过网页在设置页面中添加，例如，github是点击个人头像右边三角形，进入 Settings-&gt;SSH and GPG keys 中添加SSH key。 如果是自己通过openssh搭建的服务器，可把公钥传送到远程主机host上面：1ssh-copy-id user@host 远程主机将用户的公钥，保存在登录后的用户主目录的 ~/.ssh/authorized_keys 文件中 测试连接12345ssh -T git@github.com//成功Hi jeskinfly! You&apos;ve successfully authenticated, but GitHub does not provide shell access.//失败The authenticity of host &apos;github.com (192.30.252.1)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? GithubGitHub Pages包含两种类型: User/Organization Pages and Project Pages。自 2016.6.16 起，支持 HTTPS 协议。User Pages site，默认用来构建和发布静态页面的分支是 master 分支 。在Github中创建User Pages项目, 名称格式: username.github.io ( username 是你的账户名)。 安装Hexo12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server Hexo配置及使用参考官方 Hexo中文站点。 配置配置根目录 站点配置文件 : _config.yml。12345678910111213141516171819202122232425262728293031# Sitetitle: Jeskinfly's blogsubtitle: Quick notesdescription: Jeskinfly's blogauthor: Jeskinflylanguage: zh-Hanstimezone: UTC# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://blog.mealive.cn/...# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next // 使用的主题# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git //使用git部署 repo: git@github.com:jeskinfly/jeskinfly.github.io.gitbranch: mastersearch: // 站内搜索 path: search.xml field: post format: html limit: 10000 以上列出部分重点内容，其他可使用默认值，具体参考官方文档。 部署 Git安装 hexo-deployer-git。1$ npm install hexo-deployer-git --save 注: –save参数可追加依赖关系到 package.json 文件中，这样在Travis CI中配置自动化部署时，只需在配置文件 .travis.yml 的install:部分为:12install: - npm install #安装hexo及插件 否则要使用:1234install: - npm install #安装hexo依赖 - npm install hexo-deployer-git 安装部署插件 - npm install hexo-generator-searchdb 安装站点搜索插件 主题创建 Hexo主题 非常容易，您只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改 站点配置文件 内的 theme 设定，即可切换主题。 NexT主题安装 NexT主题 ,点击下载 NexT主题 。下载后，放在根目录下的 themes 文件夹下,并命名文件为 next。 修改默认的样式在主题下的 /themes/next/source/_custom/custom.styl 文件中增加样式覆盖默认样式。 NexT主题配置(未安装此主题请忽略)修改 主题配置文件 –&gt; /themes/next/_config.yml 。具体修改请点击查看 NexT主题官方文档 添加「标签」页面在 _posts 同级新增目录并命名为 tags ，新建 index.md 文件,里面内容如下: 12345---title: 标签date: 2017-07-07 12:22:11type: &quot;tags&quot;--- 添加「分类」页面在 _posts 同级新增目录并命名为 categories ,新建 index.md 文件,里面内容如下: 12345---title: 分类date: 2017-07-07 12:23:36type : &quot;categories&quot;--- 腾讯公益404页面新建 404.html 页面，放到主题的 source 目录下，内容如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; NexT主题第三方服务1、阅读次数统计（LeanCloud） 由 Doublemine 贡献请查看 为NexT主题添加文章阅读量统计功能2、Local Search 由 flashlab 贡献 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 配置自定义域名假设域名: blog.mealive.com1、在域名服务商添加 CHNME记录，假设域名2、在 github 中的 *.github.io 仓库的设置界面设置域名3、在项目根目录新建文件CNAME,内容如下：blog.mealive.cn 注意:1、不要 http,https,www 等前缀。2、可用在 _posts 目录同级下创建文件 CNAME，每次执行 hexo d 命令, 会自动复制一份到 public 目录中。 您可能还会关注: 使用 Travis CI自动持续化部署博客 。]]></content>
      <categories>
        <category>Github</category>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误的 git reset --hard 操作]]></title>
    <url>%2F2017%2F07%2F07%2Fgit-reset%2F</url>
    <content type="text"><![CDATA[场景 通过 vagrant 安装 box – homestead，并把里面相应的配置都修改好了，并执行过 git add 和 git commit，但是本应在另一个目录执行git reset --hard 操作，却因没有切换目录，导致所有的修改失效。如何恢复到已修改好的那个状态&nbsp;? 测试新增仓库并增加提交记录12345678$ mkdir test$ cd test$ git init$ touch a.txt$ git add a.txt$ git commit -m "initial commit"$ echo 'new data' &gt;&gt; a.txt$ git commit -a -m "add something" 查看提交记录123456789101112$ git log -2commit 2d22a9f20a7a14021b6b2bafaae6bf57985b8435 (HEAD -&gt; master)Author: Zhenliang Zhou &lt;zhouzhenliang@shucong.com&gt;Date: Fri Jul 7 10:14:04 2017 +0800 add somethingcommit 355382785fca8936eba4f5b1ccfb3f5675d1fc14Author: Zhenliang Zhou &lt;zhouzhenliang@shucong.com&gt;Date: Fri Jul 7 10:13:48 2017 +0800 initial commit 返回到上次提交123456789$ git reset --hard 355382785fca8936eba4f5b1ccfb3f5675d1fc14$ cat a.txt$ git logcommit 355382785fca8936eba4f5b1ccfb3f5675d1fc14 (HEAD -&gt; master)Author: Zhenliang Zhou &lt;zhouzhenliang@shucong.com&gt;Date: Fri Jul 7 10:13:48 2017 +0800 initial commit 现在情况正好模拟了文章开头提到的场景，这时该怎么回到第二次提交。 前进到最后一次提交git reflog 会记录与 HEAD 相关操作的记录1234567891011121314151617$ git reflog3553827 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 355382785fca8936eba4f5b1ccfb3f5675d1fc142d22a9f HEAD@&#123;1&#125;: commit: add something3553827 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): initial commit$ git reset --hard 2d22a9f$ git log -2commit 2d22a9f20a7a14021b6b2bafaae6bf57985b8435 (HEAD -&gt; master)Author: Zhenliang Zhou &lt;zhouzhenliang@shucong.com&gt;Date: Fri Jul 7 10:14:04 2017 +0800 add somethingcommit 355382785fca8936eba4f5b1ccfb3f5675d1fc14Author: Zhenliang Zhou &lt;zhouzhenliang@shucong.com&gt;Date: Fri Jul 7 10:13:48 2017 +0800 initial commit 总结 综合使用 git reflog 和 git reset --hard 可以找回丢到的代码。]]></content>
      <categories>
        <category>Git</category>
        <category>reset</category>
      </categories>
      <tags>
        <tag>Git命令</tag>
      </tags>
  </entry>
</search>
